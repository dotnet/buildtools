<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" DefaultTargets="Build" TreatAsLocalProperty="BuildProjectReferences" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <!-- The following properties are expected to change as we transition from
       Beta -> RC - RTM. We should set $(IncludeBuildNumberInPackageVersion)
       to false for the Beta/RC builds that get uploaded to NuGet.
  -->

  <PropertyGroup>
    <Version Condition="'$(StableVersion)' != ''">$(StableVersion)</Version>

    <PreReleaseLabel Condition="'$(PreReleaseLabel)' == ''">rc2</PreReleaseLabel>
    <IncludeBuildNumberInPackageVersion Condition="'$(IncludeBuildNumberInPackageVersion)' == ''">true</IncludeBuildNumberInPackageVersion>

    <VersionSuffix Condition="'$(PreReleaseLabel)' != ''">-$(PreReleaseLabel)</VersionSuffix>
    <VersionSuffix Condition="'$(IncludeBuildNumberInPackageVersion)' == 'true'">$(VersionSuffix)-$(BuildNumberMajor)-$(BuildNumberMinor)</VersionSuffix>
    
    <!--
      Empty out the project properties because we want configuration and platform to come from the individual
      projects instead of being overridden by the value the packages have.
    -->
    <ProjectProperties></ProjectProperties>

    <PackageRevStableToPrerelease Condition="'$(PackageRevStableToPrerelease)' == ''">false</PackageRevStableToPrerelease>
    <DependencyRevStableToPrerelease Condition="'$(PackageRevStableToPrerelease)' == ''">false</DependencyRevStableToPrerelease>

    <!-- By default we'll build libraries referenced by packages -->
    <BuildPackageLibraryReferences Condition="'$(BuildPackageLibraryReferences)' == ''">true</BuildPackageLibraryReferences>
  </PropertyGroup>

  <PropertyGroup Condition="'$(IsRuntimePackage)' == 'true' or '$(PackageTargetRuntime)' != ''">
    <IdPrefix>runtime.</IdPrefix>
    <IdPrefix Condition="'$(PackageTargetRuntime)' != ''">$(IdPrefix)$(PackageTargetRuntime).</IdPrefix>
    <IdPrefix Condition="'$(PackageTargetFramework)' != ''">$(IdPrefix)$(PackageTargetFramework).</IdPrefix>
  </PropertyGroup>

  <!--
       NuSpec configuration.

       NOTE: It's by design that these properties override the project. We don't
       want projects to specify any metadata, most of the metadata should be
       the same for all packages, and the rest will be centralized.
  -->
  <PropertyGroup>
    <BaseId>$(MSBuildProjectName)</BaseId>
    <Id>$(IdPrefix)$(BaseId)</Id>
    <!-- It is by design that the Title matches the Id. We want users to get an assembly view. -->
    <Title>$(Id)</Title>
    <Authors>Microsoft</Authors>
    <Owners>microsoft,dotnetframework</Owners>
    <Description>TODO</Description>
    <ReleaseNotes></ReleaseNotes>
    <ProjectUrl></ProjectUrl>
    <LicenseUrl>http://go.microsoft.com/fwlink/?LinkId=329770</LicenseUrl>
    <IconUrl>http://go.microsoft.com/fwlink/?LinkID=288859</IconUrl>
    <Copyright>&#169; Microsoft Corporation.  All rights reserved.</Copyright>
    <Tags></Tags>
    <RequireLicenseAcceptance>true</RequireLicenseAcceptance>
    <!-- we depend on nuget v3.4 behavior -->
    <MinClientVersion Condition="'$(MinClientVersion)' == ''">3.4</MinClientVersion>
  </PropertyGroup>

  <!-- Shared properties -->
  <PropertyGroup>
    <PackageOutputPath Condition="'$(PackageOutputPath)' == ''">$(BaseOutputPath)pkg/</PackageOutputPath>
    <SymbolPackageOutputPath Condition="'$(SymbolPackageOutputPath)' == ''">$(BaseOutputPath)symbolpkg/</SymbolPackageOutputPath>
    <OutputPath>$(PackageOutputPath)</OutputPath>
    <NuSpecOutputPath Condition="'$(NuSpecOutputPath)' == ''">$(PackageOutputPath)specs/</NuSpecOutputPath>
    <NuSpecPath>$(NuSpecOutputPath)$(Id)$(NuspecSuffix).nuspec</NuSpecPath>
    <PackageReportDir Condition="'$(PackageReportDir)' == ''">$(PackageOutputPath)reports/</PackageReportDir>
    <PackageReportPath>$(PackageReportDir)$(Id)$(NuspecSuffix).json</PackageReportPath>
    <TargetPath>$(NuSpecPath)</TargetPath>
    <RuntimeFilePath Condition="'$(RuntimeFilePath)' == ''">$(NuSpecOutputPath)$(Id)$(NuspecSuffix)/runtime.json</RuntimeFilePath>
    <PlaceholderFile>$(MSBuildThisFileDirectory)_._</PlaceholderFile>
    <PackageDescriptionFile Condition="'$(PackageDescriptionFile)' == ''">path to descriptions.json must be specified</PackageDescriptionFile>
    <RuntimeIdGraphDefinitionFile Condition="'$(RuntimeIdGraphDefinitionFile)' == ''">$(MSBuildThisFileDirectory)runtime.json</RuntimeIdGraphDefinitionFile>
    <FrameworkListsPath Condition="'$(FrameworkListsPath)' == ''">$(MSBuildThisFileDirectory)FrameworkLists</FrameworkListsPath>
    <ValidationSuppressionFile Condition="'$(ValidationSuppressionFile)' == ''">ValidationSuppression.txt</ValidationSuppressionFile>
    <SyncInfoFile Condition="'$(SyncInfoFile)' == ''">unspecified</SyncInfoFile>
    <PackagingTaskDir Condition="'$(PackagingTaskDir)' == ''">$(MSBuildThisFileDirectory)</PackagingTaskDir>
  </PropertyGroup>

  <Import Project="stable.packages.targets" />
  <Import Project="baseline.packages.targets" />

  <!-- If this package explicitly sets the StableVersion then add it to the stable list -->
  <ItemGroup Condition="'$(StableVersion)' != ''">
    <StablePackage Include="$(Id)">
      <Version>$(StableVersion)</Version>
    </StablePackage>
  </ItemGroup>

  <UsingTask TaskName="ApplyPreReleaseSuffix" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>
  <UsingTask TaskName="GetAssemblyReferences" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>
  <UsingTask TaskName="SplitReferences" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>
  <UsingTask TaskName="GenerateRuntimeDependencies" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>
  <UsingTask TaskName="GetPackageDescription" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>
  <UsingTask TaskName="GetInboxFrameworks" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>
  <UsingTask TaskName="GetPackageVersion" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>
  <UsingTask TaskName="EnsureOOBFramework" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>
  <UsingTask TaskName="ValidatePackage" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>
  <UsingTask TaskName="CreateTrimDependencyGroups" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>
  <UsingTask TaskName="GenerateNuSpec" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>
  <UsingTask TaskName="NuGetPack" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>
  <UsingTask TaskName="ApplyBaseLine" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>
  <UsingTask TaskName="PromoteReferenceDependencies" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>

  <!-- Determine if we actually need to build for this architecture -->
  <!-- Packages can specifically control their architecture by specifying the PackagePlatforms
       property as a semi-colon delimited list.
       If this is not done then the package will build if the target runtime contains the current
       architecture or if we're building for x86. -->
  <PropertyGroup>
    <PackagePlatform Condition="'$(PackagePlatform)' == ''">$(Platform)</PackagePlatform>
    <PackagePlatform Condition="'$(PackagePlatform)' == 'amd64'">x64</PackagePlatform>

    <!-- build if the package specifically requests current architecture via PackagePlatforms -->
    <ShouldGenerateNuSpec Condition="$(PackagePlatforms.Contains('$(PackagePlatform);'))">true</ShouldGenerateNuSpec>
    <!-- build if PackagePlatforms is not specified and the PackageTargetRuntime contains the current architecture -->
    <ShouldGenerateNuSpec Condition="'$(PackagePlatforms)' == '' AND $(PackageTargetRuntime.Contains('-$(PackagePlatform)'))">true</ShouldGenerateNuSpec>
    <!-- build if PackagePlatforms is not specified and arch is x86 or AnyCPU -->
    <ShouldGenerateNuSpec Condition="'$(PackagePlatforms)' == '' AND ('$(PackagePlatform)' == 'x86' OR '$(PackagePlatform)' == 'AnyCPU')">true</ShouldGenerateNuSpec>
    <!-- if we built a nuspec, also pack unless explicitly set -->
    <ShouldCreatePackage Condition="'$(ShouldCreatePackage)' == ''">$(ShouldGenerateNuSpec)</ShouldCreatePackage>
    <BuildDependsOn Condition="'$(ShouldGenerateNuSpec)' == 'true'">GenerateNuSpec</BuildDependsOn>
    <BuildDependsOn Condition="'$(ShouldCreatePackage)' == 'true'">$(BuildDependsOn);CreatePackage</BuildDependsOn>
  </PropertyGroup>

  <!-- Redefine build to just create the NuSpec only, we'll create the package during ArcProjects phase -->
  <Target Name="Build"
          DependsOnTargets="$(BuildDependsOn)">

    <Message Condition="'$(ShouldGenerateNuSpec)' == 'true'"
             Text="$(MSBuildProjectName) -> $(NuSpecPath)"
             Importance="high" />

    <Message Condition="'$(ShouldGenerateNuSpec)' != 'true'"
             Text="Skipping nuspec generation for this platform."
             Importance="high" />
  </Target>

  <Target Name="Clean">
    <!-- package version is calculated so read the last version from the marker file. -->
    <ReadLinesFromFile File="$(NuSpecPath).pkgpath"
                       Condition="Exists('$(NuSpecPath).pkgpath')">
      <Output TaskParameter="Lines" ItemName="_ToBeDeleted"/>
    </ReadLinesFromFile>

    <ItemGroup>
      <_ToBeDeleted Include="$(NuSpecPath)" />
      <_ToBeDeleted Include="$(NuSpecPath).pkgpath" />
      <_ToBeDeleted Include="$(RuntimeFilePath)" />
    </ItemGroup>
    <Delete Files="@(_ToBeDeleted)" />
  </Target>

  <Target Name="Rebuild"
          DependsOnTargets="Clean;Build" />

  <Target Name="SplitProjectReferences"
          DependsOnTargets="_GetProjectClosure">
    <ItemGroup>
      <!-- Split direct and indirect project dependencies -->
      <_PkgProjProjectReferenceClosure Include="@(_ProjectReferenceClosure)"
                                      Condition="'%(_ProjectReferenceClosure.Extension)' == '.pkgproj'" />
      <_NonPkgProjProjectReferenceClosure Include="@(_ProjectReferenceClosure)"
                                         Condition="'%(_ProjectReferenceClosure.Extension)' != '.pkgproj'" />

      <!-- Split direct project dependencies -->
      <_PkgProjProjectReference Include="@(_PkgProjProjectReferenceClosure)"
                               Condition="'%(DependencyKind)' == 'Direct'" />
      <_NonPkgProjProjectReference Include="@(_NonPkgProjProjectReferenceClosure)"
                                  Condition="'%(DependencyKind)' == 'Direct'" />

    </ItemGroup>
  </Target>


  <Target Name="GetPkgProjPackageDependencies"
          Returns="@(PkgProjDependency)"
          Inputs="%(_PkgProjProjectReferenceClosure.DependencyKind)"
          Outputs="fake"
          DependsOnTargets="SplitProjectReferences">
    <MSBuild Targets="GetPackageIdentity"
             Projects="@(_PkgProjProjectReferenceClosure)"
             Properties="%(_PkgProjProjectReferenceClosure.SetConfiguration); %(_PkgProjProjectReferenceClosure.SetPlatform)">
      <Output TaskParameter="TargetOutputs"
              ItemName="_PkgProjDependency" />
    </MSBuild>
    <ItemGroup>
      <PkgProjDependency Include="@(_PkgProjDependency)">
        <DependencyKind>%(_PkgProjProjectReferenceClosure.DependencyKind)</DependencyKind>
      </PkgProjDependency>
    </ItemGroup>
  </Target>

  <Target Name="GetFiles"
          Returns="@(File)"
          DependsOnTargets="ConvertItems" />

  <Target Name="ConvertItems"
          DependsOnTargets="ExpandProjectReferences">
    <CreateItem Include="@(ProjectReferenceOutput)">
      <Output TaskParameter="Include"
              ItemName="File"/>
    </CreateItem>
    <ItemGroup>
      <_LinkedContentFiles Include="@(Content)"
                           Condition="'%(Content.Link)' != ''" />
      <_UnlinkedContentFiles Include="@(Content)"
                             Condition="'%(Content.Link)' == ''" />
    </ItemGroup>
    <CreateItem Include="@(_LinkedContentFiles)"
                AdditionalMetadata="TargetPath=%(Link)">
      <Output TaskParameter="Include"
              ItemName="File"/>
    </CreateItem>
    <CreateItem Include="@(_UnlinkedContentFiles)"
                AdditionalMetadata="TargetPath=%(RelativeDir)">
      <Output TaskParameter="Include"
              ItemName="File"/>
    </CreateItem>

    <!-- We need to special case library files in later phases. In order to make this
         easier, we add custom metadata 'IsLibrary' that indicates whether the file is
         targeting the lib folder or not. -->

    <ItemGroup>
      <_FileWithIsLibrary Include="@(File)"
                          Condition="'%(File.TargetPath)' == 'lib' OR
                                     $([System.String]::Copy('%(File.TargetPath)').ToLower().StartsWith('lib\')) OR
                                     $([System.String]::Copy('%(File.TargetPath)').ToLower().StartsWith('lib/'))">
        <PackageDirectory>Lib</PackageDirectory>
      </_FileWithIsLibrary>
      <_FileWithIsLibrary Include="@(File)"
                          Condition="'%(File.TargetPath)' != 'lib' AND
                                     !$([System.String]::Copy('%(File.TargetPath)').ToLower().StartsWith('lib\')) AND
                                     !$([System.String]::Copy('%(File.TargetPath)').ToLower().StartsWith('lib/'))">
        <PackageDirectory></PackageDirectory>
      </_FileWithIsLibrary>
      <File Remove="@(File)" />
      <File Include="@(_FileWithIsLibrary)" />
    </ItemGroup>

  </Target>

  <Target Name="GetPackageDependencies"
          DependsOnTargets="AssignPkgProjPackageDependenciesTargetFramework;GetNuGetPackageDependencies"
          Returns="@(Dependency)">
    <ItemGroup>
      <Dependency Include="@(PkgProjDependency)"
                  Condition="'%(PkgProjDependency.DependencyKind)' == 'Direct'" />
      <Dependency Include="@(NuGetDependency)"
                  Condition="'%(NuGetDependency.DependencyKind)' == 'Direct'" />
    </ItemGroup>
  </Target>

  <Target Name="GenerateNuSpec"
          DependsOnTargets="GetPackageDependencies;GenerateRuntimeDependencies;GetPackageFiles;$(VersionDependsOn)">
    <!-- Please Note:
         In order to avoid incremental build issues this target will always run.
         However, the task will make sure that it doesn't touch the file if the
         contents it would generate are identical to a previously generated
         nuspec. -->
    <GenerateNuSpec InputFileName="$(NuSpecTemplate)"
                    OutputFileName="$(NuSpecPath)"
                    MinClientVersion="$(MinClientVersion)"
                    Id="$(Id)"
                    Version="$(Version)"
                    Title="$(Title)"
                    Authors="$(Authors)"
                    Owners="$(Owners)"
                    Description="$(Description)"
                    ReleaseNotes="$(ReleaseNotes)"
                    Summary="$(Summary)"
                    Language="$(Language)"
                    ProjectUrl="$(ProjectUrl)"
                    IconUrl="$(IconUrl)"
                    LicenseUrl="$(LicenseUrl)"
                    Copyright="$(Copyright)"
                    RequireLicenseAcceptance="$(RequireLicenseAcceptance)"
                    Tags="$(Tags)"
                    DevelopmentDependency="$(DevelopmentDependency)"
                    Dependencies="@(Dependency)"
                    References="@(Reference)"
                    FrameworkReferences="@(FrameworkReference)"
                    Files="@(PackageFile)"/>
  </Target>

  <PropertyGroup>
    <!-- exclude reference assets for runtime packages
         these assets are only packaged in the reference packages.  Even
         if they have a runtime asset we package it in the reference package
         for better compression.  -->
    <ExcludeReferenceAssets Condition="'$(ExcludeReferenceAssets)' == '' AND '$(PackageTargetRuntime)' != ''">true</ExcludeReferenceAssets>
  </PropertyGroup>

  <!-- We define a custom target: GetFilesToPackage which does a minimal build of the project
       and passes all information in a single item group.
       This helps minimize the number of project evaluations and targets that build in order
       to determine the contents of the package-->
  <Target Name="ExpandProjectReferences"
          DependsOnTargets="SplitProjectReferences">

    <!-- Only rebuild project references when specified -->
    <MSBuild Targets="Build"
             Condition="'$(BuildPackageLibraryReferences)' == 'true'"
             Projects="@(_NonPkgProjProjectReference)"
             Properties="$(ProjectProperties)"
             ContinueOnError="WarnAndContinue"/>

    <MSBuild Targets="GetFilesToPackage"
             BuildInParallel="$(BuildInParallel)"
             Projects="@(_NonPkgProjProjectReference)"
             Properties="$(ProjectProperties)">
      <Output TaskParameter="TargetOutputs"
              ItemName="_FilesToPackage" />
    </MSBuild>

    <ItemGroup>
      <_FilesToPackage Remove="@(_FilesToPackage)" Condition="'$(ExcludeReferenceAssets)' == 'true' AND '%(_FilesToPackage.IsReferenceAsset)' == 'true'" />
      <File Include="@(_FilesToPackage)">
        <PackageId>$(Id)</PackageId>
        <PackageVersion>$(Version)</PackageVersion>
        <!-- Some packages support legacy portable profiles where dependencies are provided by targeting pack -->
        <HarvestDependencies Condition="!$([System.String]::new('%(_FilesToPackage.TargetFramework)').StartsWith('portable-'))">true</HarvestDependencies>
      </File>
    </ItemGroup>

    <Error Condition="'$(SkipPackageFileCheck)' != 'true' AND
                      '%(File.SkipPackageFileCheck)' != 'true' AND
                      '%(File.FileName)' != '_' AND
                      '%(File.FileName)%(File.Extension)' != 'runtime.json' AND
                      '%(File.Extension)' != '.cs' AND
                      '%(File.Extension)' != '.vb' AND
                      !$(ID.Contains('%(File.FileName)'))"
           Text="Package $(ID) contains file with name %(File.FileName).  If this is expected you can disable this filename checking for this item or package by setting SkipPackageFileCheck = true"
           ContinueOnError="ErrorAndContinue" />
  </Target>

  <!-- Permit setting TargetFramework and add our own metadata (TargetRuntime) -->
  <Target Name="GetPackageIdentity"
          Returns="@(_PackageIdentity)"
          DependsOnTargets="$(VersionDependsOn)">
    <ItemGroup>
      <_PackageIdentity Include="$(Id)">
        <Version>$(Version)</Version>
        <TargetFramework Condition="'$(PackageTargetFramework)' != ''">$(PackageTargetFramework)</TargetFramework>
        <TargetRuntime Condition="'$(PackageTargetRuntime)' != ''">$(PackageTargetRuntime)</TargetRuntime>
      </_PackageIdentity>
    </ItemGroup>
  </Target>

  <!-- Don't actually walk the closure all the time, conditioned on GetClosure metadata on ProjectReference.
       Walking the closure is very expensive for many of our packages and is unecessary since we are very
       strict about assets that are included in the package.  -->
  <Target Name="_GetProjectClosure" DependsOnTargets="ConvertCommonMetadataToAdditionalProperties"
          Returns="@(_ProjectReferenceClosure)">

    <!-- Get closure of indirect references if they opt-in -->
    <MSBuild Projects="@(ProjectReference)"
             Targets="_GetProjectClosure"
             Properties="$(ProjectProperties)"
             ContinueOnError="WarnAndContinue"
             BuildInParallel="$(BuildInParallel)"
             Condition="'%(ProjectReference.GetClosure)' == 'true'">
      <Output TaskParameter="TargetOutputs"
              ItemName="_ProjectReferenceClosureWithDuplicates" />
    </MSBuild>

    <!-- Remove duplicates from closure -->
    <RemoveDuplicates Inputs="@(_ProjectReferenceClosureWithDuplicates)">
      <Output TaskParameter="Filtered"
              ItemName="_ProjectReferenceClosureWithoutMetadata"/>
    </RemoveDuplicates>

    <ItemGroup>
      <!-- Remove references that are also direct references -->
      <_ProjectReferenceClosureWithoutMetadata Remove="%(ProjectReference.FullPath)" />
      <!-- We can now mark all the closure references as indirect -->
      <_ProjectReferenceClosure Include="@(_ProjectReferenceClosureWithoutMetadata)">
        <DependencyKind>Indirect</DependencyKind>
        <PackageDirectory>%(ProjectReference.PackageDirectory)</PackageDirectory>
      </_ProjectReferenceClosure>
      <!-- Now add the direct references, preserving metadata -->
      <_ProjectReferenceClosure Include="@(ProjectReference->'%(FullPath)')">
        <DependencyKind>Direct</DependencyKind>
      </_ProjectReferenceClosure>
    </ItemGroup>

  </Target>

  <Target Name="AssignPkgProjPackageDependenciesTargetFramework"
          DependsOnTargets="GetPkgProjPackageDependencies;GetFiles;EnsureOOBFramework">

    <ItemGroup>
      <!-- ensure that unconstrained dependencies are also expanded in constrained TFM groups -->
      <_PkgProjDependencyWithoutTFM Include="@(PkgProjDependency)" Condition="'%(PkgProjDependency.TargetFramework)' == '' AND '%(PkgProjDependency.DoNotExpand)' != 'true'" />
      <_AllPkgProjTFMs Include="%(PkgProjDependency.TargetFramework)" Condition="'%(PkgProjDependency.DependencyKind)' == 'Direct'" />
      <!-- Include file TFMs -->
      <_AllPkgProjTFMs Include="%(File.TargetFramework)" Condition="'%(File.TargetFramework)' != ''" />

      <!-- Remove dependencies without a TFM so they can be replaced -->
      <PkgProjDependency Remove="@(_PkgProjDependencyWithoutTFM)" />
      <!-- operate on pkgproj dependencies and file dependencies -->
      <PkgProjDependency Include="@(_PkgProjDependencyWithoutTFM)">
        <TargetFramework>%(_AllPkgProjTFMs.Identity)</TargetFramework>
      </PkgProjDependency>
    </ItemGroup>
  </Target>

  <!-- Don't do any filtering of files.
       We explicitly determine package content so we do not need to
       filter out files that come from dependent packages. -->
  <Target Name="GetPackageFiles"
          Returns="@(PackageFile)"
          DependsOnTargets="GetFiles;EnsureOOBFramework;$(VersionDependsOn)">
    <ItemGroup>
      <!-- Include all files except source files. Sources need to be deduplicated. -->
      <PackageFile Include="@(File)" Condition="'%(File.IsSourceCodeFile)'!='true'" />
      <PackageFile Condition="'%(PackageFile.PackageId)' == ''">
        <PackageId>$(Id)</PackageId>
        <PackageVersion>$(Version)</PackageVersion>
      </PackageFile>

      <!-- Include Sources. Deduplicate so the nuspec doesn't contain multiple entries for each source file. -->
      <PackageSources Include="@(File)"
                      KeepMetadata="TargetPath;IsSourceCodeFile"
                      KeepDuplicates="false"
                      Condition="'%(File.IsSourceCodeFile)'=='true'" />
      <!-- Add a placeholder source file if there are symbols but no sources. -->
      <PackageSymbolFiles Include="@(File)" Condition="'%(File.IsSymbolFile)'=='true'" />
      <PackageSources Include="$(PlaceholderFile)" Condition="'@(PackageSymbolFiles)'!='' AND '@(PackageSources)'==''">
        <IsSourceCodeFile>true</IsSourceCodeFile>
        <TargetPath>src</TargetPath>
      </PackageSources>
      <PackageFile Include="@(PackageSources)" />

      <!-- Nuget will treat TargetPath as a directory if the extensions dont match,
           however we need to package files without an extension (Unix exectuables).
           As such nuget will always consider TargetPath to be a file path for these
           files.  Ensure that the TargetPath is the file path for these files. -->
      <PackageFile Condition="'%(Extension)' == ''">
        <TargetPath>%(PackageFile.TargetPath)/%(FileName)</TargetPath>
      </PackageFile>
    </ItemGroup>
  </Target>

  <!-- Harvest dependencies from assembly references.
       Assume version of package dependency == assembly version of dependency (3-part).
       For prerelease (not stable) packages apply a pre-release suffix to the dependency -->
  <Target Name="GetFilePackageReferences"
          DependsOnTargets="EnsureOOBFramework"
          Condition="'$(OmitDependencies)' != 'true'"
          Inputs="%(File.Identity);%(File.TargetFramework)"
          Outputs="fake">
    <!-- Generate package references based on assembly dependencies -->
    <GetAssemblyReferences Assemblies="@(File)" Condition="'%(File.HarvestDependencies)' == 'true' and '%(File.Extension)' == '.dll'">
      <Output TaskParameter="ReferencedAssemblies"
              ItemName="_FileReferencedAssemblies"/>
    </GetAssemblyReferences>

    <PropertyGroup>
      <_TargetFramework>%(File.TargetFramework)</_TargetFramework>
    </PropertyGroup>

    <SplitReferences References="@(_FileReferencedAssemblies)"
                     TargetFramework="$(_TargetFramework)"
                     FrameworkListsPath="$(FrameworkListsPath)">
      <Output TaskParameter="FrameworkReferences" ItemName="_FileFrameworkReference"/>
      <Output TaskParameter="PackageReferences" ItemName="_FilePackageReference"/>
    </SplitReferences>
    
    <ItemGroup Condition="'@(_FilePackageReference)' != ''">
      <_FilePackageReference Remove="corefx;mscorlib;System;System.Core;System.Xml;Windows" />
      <_FilePackageReference Remove="@(_FilePackageReference)"
                             Condition="$([System.String]::new('%(Identity)').StartsWith('Internal.'))"/>
      <_FilePackageReference Remove="@(_FilePackageReference)"
                             Condition="$([System.String]::new('%(Identity)').StartsWith('System.Private.'))"/>
      <_FilePackageReference Remove="@(PackageDependencyExclude)"/>

      <!-- Projects may specify additional references by assembly name & identity that we'll process
           applying pre-release logic -->
      <_FilePackageReference Include="@(AdditionalAssemblyReference)"/>

      <_FilePackageReference Condition="'%(Identity)' == '@(FileRuntimeDependency)'">
        <TargetRuntime>@(FileRuntimeDependency->'%(TargetRuntime)')</TargetRuntime>
      </_FilePackageReference>
    </ItemGroup>
    
    <ItemGroup>
      <FilePackageDependency Include="@(_FilePackageReference)" />
      <!-- Only add framework references for desktop frameworks -->
      <FrameworkReference Condition="$(_TargetFramework.StartsWith('net4'))" Include="@(_FileFrameworkReference)" KeepDuplicates="false" />
    </ItemGroup>
  </Target>

  <Target Name="GetNuGetPackageDependencies"
          DependsOnTargets="CreateVersionFileDuringBuild;GetFilePackageReferences">
    <PropertyGroup>
      <!-- determine if we have any reference assets in the package (files in the ref folder) -->
      <_containsReferenceAsset Condition="'%(File.IsReferenceAsset)' == 'true'">true</_containsReferenceAsset>
    </PropertyGroup>

    <ItemGroup Condition="'$(_containsReferenceAsset)' == 'true'">
      <!-- If the package contains a reference asset, then make all non-reference dependencies
           exclude compile assets, so as not to leak implementation dependencies into the compile
           graph.-->
      <FilePackageDependency>
        <Exclude Condition="'%(FilePackageDependency.IsReferenceAsset)' != 'true'">Compile</Exclude>
      </FilePackageDependency>
    </ItemGroup>
      
    
   <!-- We can reduce the number of dependencies listed for any framework that has
        inbox implementations since that framework doesn't need the packages for
        compile/runtime.  This reduces the noise when consuming our packages in
        packages.config based projects.  -->
    <CreateTrimDependencyGroups Dependencies="@(FilePackageDependency);@(Dependency)"
                      FrameworkListsPath="$(FrameworkListsPath)"
                      Files="@(File)"
                      UseNetPlatform="$(UseNetPlatform)"
                      Condition="'@(FilePackageDependency)' != '' AND '$(PackageTargetRuntime)' == ''">
      <Output TaskParameter="TrimmedDependencies" ItemName="FilePackageDependency" />
    </CreateTrimDependencyGroups>

    <!-- Promote reference dependencies to implementation TargetFrameworks -->
    <PromoteReferenceDependencies Dependencies="@(FilePackageDependency)"
                                  FrameworkListsPath="$(FrameworkListsPath)"
                                  Condition="'@(FilePackageDependency)' != ''">
      <Output TaskParameter="PromotedDependencies" ItemName="FilePackageDependency" />
    </PromoteReferenceDependencies>

    <ApplyBaseLine OriginalDependencies="@(FilePackageDependency)" BaseLinePackages="@(BaseLinePackage)" Condition="'$(BaseLinePackageDependencies)' != 'false'">
      <Output TaskParameter="BaseLinedDependencies" ItemName="_BaseLinedDependencies" />
    </ApplyBaseLine>
    
    <!-- if not baselining, flow the dependencies unmodified -->
    <ItemGroup Condition="'$(BaseLinePackageDependencies)' == 'false'">
      <_BaseLinedDependencies Include="@(FilePackageDependency)" />
    </ItemGroup>

    <ApplyPreReleaseSuffix Condition="'@(_BaseLinedDependencies)' != ''" StablePackages="@(StablePackage)" OriginalPackages="@(_BaseLinedDependencies)" PreReleaseSuffix="$(VersionSuffix)" RevStableToPrerelease="$(DependencyRevStableToPrerelease)">
      <Output TaskParameter="UpdatedPackages" ItemName="Dependency"/>
    </ApplyPreReleaseSuffix>

  </Target>

  <!-- Walks every project gathering its AssemblyVersion, choosing the highest -->
  <!-- Skipped if the package explicitly defines a version -->
  <Target Name="GetAssemblyVersionFromProjects"
          Condition="$(Version) == ''"
          DependsOnTargets="ExpandProjectReferences">

    <GetPackageVersion Files="@(File)">
      <Output TaskParameter="Version" PropertyName="_AssemblyVersion" />
    </GetPackageVersion>

    <Error Condition="'$(_AssemblyVersion)' == ''"
           Text="No assembly version could be determined."
           ContinueOnError="ErrorAndContinue" />
  </Target>

  <!-- Calculates the package version including any prerelease suffix -->
  <Target Name="CalculatePackageVersion"
        BeforeTargets="GenerateNuSpec;GetPackageIdentity"
        DependsOnTargets="CreateVersionFileDuringBuild;GetAssemblyVersionFromProjects">

    <Error Text="No version could be detected.  Either specify the Version property or provide at least one managed assembly."
           Condition="'$(Version)' == '' AND '$(_AssemblyVersion)' == ''"
           ContinueOnError="ErrorAndContinue" />

    <ItemGroup>
      <_thisPackage Include="$(Id)">
        <Version Condition="'$(Version)' != ''">$(Version)</Version>
        <Version Condition="'$(Version)' == ''">$(_AssemblyVersion)</Version>
      </_thisPackage>
    </ItemGroup>


    <ApplyPreReleaseSuffix StablePackages="@(StablePackage)" OriginalPackages="@(_thisPackage)" PreReleaseSuffix="$(VersionSuffix)" RevStableToPrerelease="$(PackageRevStableToPrerelease)">
      <Output TaskParameter="UpdatedPackages" ItemName="_thisPackageFinal"/>
    </ApplyPreReleaseSuffix>

    <PropertyGroup>
      <Version>%(_thisPackageFinal.Version)</Version>
    </PropertyGroup>
  </Target>

  <Target Name="DetermineRuntimeDependencies"
          DependsOnTargets="GetPackageDependencies"
          Returns="@(RuntimeDependency)">
    <!-- see if we have any runtime dependencies to write to runtime.json -->
    <ItemGroup>
      <RuntimeDependency Condition="'%(Dependency.TargetRuntime)' != ''" Include="@(Dependency)"/>
      <RuntimeDependency>
        <TargetPackage Condition="'%(RuntimeDependency.TargetPackage)' == ''">$(Id)</TargetPackage>
      </RuntimeDependency>
      <!-- don't include runtime depdendencies in the dependency list, they'll be written to the runtime.json -->
      <Dependency Remove="@(RuntimeDependency)"/>
    </ItemGroup>

    <Error Text="Packages that are constrained by runtime should not have runtime dependencies.  They will be ignored by nuget"
           Condition="'$(PackageTargetRuntime)' != '' AND '@(RuntimeDependency)' != ''"
           ContinueOnError="ErrorAndContinue" />

    <!-- determine if there is a file to be updated, and setup the output file -->
    <PropertyGroup>
      <RuntimeFileSource Condition="'%(File.FileName)%(File.Extension)' == 'runtime.json'">%(File.Identity)</RuntimeFileSource>
    </PropertyGroup>

    <!-- only include runtime.json in lineup packages -->
    <ItemGroup Condition="'$(IsLineupPackage)' == 'true' OR '$(IncludeRuntimeJson)' == 'true'">
      <!-- if we are updating, remove it from the file group, we'll replace it with the generated version -->
      <PackageFile Condition="'$(RuntimeFileSource)' != ''" Remove="$(RuntimeFileSource)"/>
      <PackageFile Include="$(RuntimeFilePath)">
        <PackageId>$(Id)</PackageId>
        <PackageVersion>$(Version)</PackageVersion>
        <IsLibrary>false</IsLibrary>
      </PackageFile>
    </ItemGroup>
  </Target>

  <Target Name="EnsureEmptyPackage"
          DependsOnTargets="DetermineRuntimeDependencies"
          BeforeTargets="GenerateNuSpec">
    <!-- Nuget will include all files when nuspec is empty, ensure we have at least one file to avoid that -->
    <ItemGroup Condition="'@(PackageFile)' == ''">
      <PackageFile Include="$(PlaceholderFile)">
        <PackageId>$(Id)</PackageId>
        <PackageVersion>$(Version)</PackageVersion>
        <IsLibrary>false</IsLibrary>
      </PackageFile>
    </ItemGroup>
  </Target>

  <!-- If the "PreventImplementationReference" property is true, then don't permit references to the
    package implementation from lib.  This is used in the platform specific packages which should
    not be directly referenced by projects for implemtation dependencies. -->
  <Target Name="PreventImplementationReference"
          BeforeTargets="EnsureEmptyPackage">
    <ItemGroup Condition="'$(PreventImplementationReference)' == 'true'">
      <PackageFile Include="$(PlaceholderFile)">
        <PackageId>$(Id)</PackageId>
        <PackageVersion>$(Version)</PackageVersion>
        <TargetPath Condition="'$(UseNetPlatform)' != 'true'">ref/netstandard</TargetPath>
        <TargetPath Condition="'$(UseNetPlatform)' == 'true'">ref/dotnet</TargetPath>
      </PackageFile>
    </ItemGroup>
  </Target>


  <!--
      InboxOnTargetFramework: contract implementation and reference are inbox, use placeholders for both
      NotSupportedOnTargetFramework: contract should not be supported, use place holder for lib
      ExternalOnTargetFramework: contract implementation is provided by another package, use placeholders for both
  -->
  <Target Name="AddPlaceholders"
          DependsOnTargets="ExpandProjectReferences"
          Inputs="%(InboxOnTargetFramework.Identity);%(NotSupportedOnTargetFramework.Identity);%(ExternalOnTargetFramework.Identity)"
          Outputs="fake"
          BeforeTargets="ConvertItems">
    <ItemGroup>
      <_targetItem Include="@(InboxOnTargetFramework)"/>
      <_targetItem Include="@(NotSupportedOnTargetFramework)"/>
      <_targetItem Include="@(ExternalOnTargetFramework)"/>
    </ItemGroup>
    <PropertyGroup>
      <_target>%(_targetItem.Identity)</_target>
      <_targetRuntime>$(PackageTargetRuntime)</_targetRuntime>
      <_targetRuntime Condition="'%(_targetItem.PackageTargetRuntime)' != ''">%(_targetItem.PackageTargetRuntime)</_targetRuntime>
      <!-- don't use 'any' in paths due to https://github.com/NuGet/Home/issues/1676 -->
      <_targetRuntime Condition="'$(_targetRuntime)' == 'any'"></_targetRuntime>
      <!-- include a ref placeholder for everything but NotSupportedOnTargetFramework, never put placeholders in runtime packages -->
      <_targetRef Condition="'%(NotSupportedOnTargetFramework.Identity)' == '' AND '$(PackageTargetRuntime)' == ''">true</_targetRef>
    </PropertyGroup>
    <ItemGroup>
      <File Include="$(PlaceholderFile)">
        <PackageId>$(Id)</PackageId>
        <PackageVersion>$(Version)</PackageVersion>
        <TargetPath Condition="'$(_targetRuntime)' != ''">runtimes/$(_targetRuntime)/lib/$(_target)</TargetPath>
        <TargetPath Condition="'$(_targetRuntime)' == ''">lib/$(_target)</TargetPath>
      </File>
      <File Include="$(PlaceholderFile)" Condition="'$(_targetRef)' == 'true'">
        <PackageId>$(Id)</PackageId>
        <PackageVersion>$(Version)</PackageVersion>
        <TargetPath>ref/$(_target)</TargetPath>
      </File>
      <FrameworkReference Condition="'%(InboxOnTargetFramework.AsFrameworkReference)' == 'true'" Include="$(Id)">
        <TargetFramework>$(_target)</TargetFramework>
      </FrameworkReference>
      <Dependency Include="_._">
        <TargetFramework>$(_target)</TargetFramework>
      </Dependency>
    </ItemGroup>
  </Target>

  <!-- Ensures that OOB frameworks aren't obscured by placeholders for inbox frameworks
       This is needed because nuget treats portable implementations as having less
       precedence than platform specific implementations of any version and we
       put a place-holder in the platform specific folder when an asset is inbox. -->
  <ItemGroup>
    <OutOfBoxFramework Include="netcore50"/>
  </ItemGroup>
  <Target Name="EnsureOOBFramework"
          DependsOnTargets="AddPlaceholders;GetFiles">
    <EnsureOOBFramework Condition="'@(OutOfBoxFramework)' != ''" OOBFrameworks="@(OutOfBoxFramework)" Files="@(File)" RuntimeJson="$(RuntimeIdGraphDefinitionFile)" RuntimeId="$(PackageTargetRuntime)">
      <Output TaskParameter="AdditionalFiles" ItemName="File" />
    </EnsureOOBFramework>
  </Target>

  <!-- Generates a runtime.json file containing all dependencies with TargetRuntime -->
  <Target Name="GenerateRuntimeDependencies"
          DependsOnTargets="DetermineRuntimeDependencies"
          BeforeTargets="GenerateNuspec">
    <ItemGroup>
      <LineupProjectReference Include="@(ProjectReference)" />
    </ItemGroup>

    <!-- Lineups need to have all runtime dependencies to ensure that they are part of the compile graph -->
    <MSBuild Projects="@(LineupProjectReference)" Targets="DetermineRuntimeDependencies" Condition="'$(IsLineupPackage)' == 'true'" Properties="$(ProjectProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_indirectRuntimeDependencies" />
    </MSBuild>

    <!-- pass both RuntimeDependencies and regular dependencies.
         Only RuntimeDependencies will be generated, but Dependencies are required
         since they may be the target of a RuntimeDependency -->
    <GenerateRuntimeDependencies Condition="'@(RuntimeDependency)' != '' OR '@(_indirectRuntimeDependencies)' != ''"
                                 Dependencies="@(RuntimeDependency);@(Dependency);@(_indirectRuntimeDependencies)"
                                 PackageId="$(Id)"
                                 RuntimeJsonTemplate="$(RuntimeFileSource)"
                                 RuntimeJson="$(RuntimeFilePath)"
                                 EnsureBase="$(IsLineupPackage)"/>
  </Target>

  <Target Name="GetSyncInfo"
    BeforeTargets="GetPackageDescription"
    Condition="Exists('$(SyncInfoFile)')">
    <ReadLinesFromFile
      File="$(SyncInfoFile)">
      <Output
        TaskParameter="Lines"
        ItemName="SyncInfoLines" />
    </ReadLinesFromFile>
  </Target>

  <Target Name="GetPackageDescription"
          BeforeTargets="GenerateNuspec">
    <PropertyGroup>
      <UseRuntimePackageDescription Condition="'$(UseRuntimePackageDescription)' == '' AND $(BaseId.StartsWith('runtime.native'))">true</UseRuntimePackageDescription>
    </PropertyGroup>

    <GetPackageDescription DescriptionFile="$(PackageDescriptionFile)"
                           Condition="'$(UseRuntimePackageDescription)' != 'true'"
                           PackageId="$(BaseId)">
      <Output TaskParameter="Description"
              PropertyName="Description" />
    </GetPackageDescription>

    <GetPackageDescription DescriptionFile="$(PackageDescriptionFile)"
                           Condition="'$(PackageTargetRuntime)' != '' OR '$(UseRuntimePackageDescription)' == 'true'"
                           PackageId="RuntimePackage">
      <Output TaskParameter="Description"
              PropertyName="RuntimeDisclaimer" />
    </GetPackageDescription>

    <PropertyGroup>
      <Description Condition="'$(UseRuntimePackageDescription)' == 'true' AND '$(RuntimeDisclaimer)' != ''">$(RuntimeDisclaimer)</Description>
      <Description Condition="'$(UseRuntimePackageDescription)' != 'true' AND '$(RuntimeDisclaimer)' != ''">$(RuntimeDisclaimer) %0A$(Description)</Description>
      <Description Condition="'@(SyncInfoLines)' != ''">$(Description) %0A%(SyncInfoLines.Identity)</Description>
    </PropertyGroup>
  </Target>

  <ItemGroup>
    <!-- Default validation frameworks : every framework that supports contracts -->
    <DefaultValidateFramework Include="netstandardapp1.5">
      <RuntimeIDs>win7-x86;win7-x64;osx.10.11-x64;centos.7.1-x64;ubuntu.14.04-x64;linuxmint.17-x64</RuntimeIDs>
    </DefaultValidateFramework>

    <DefaultValidateFramework Include="netcore50">
      <RuntimeIDs>win10-x86;win10-x86-aot;win10-x64;win10-x64-aot;win10-arm;win10-arm-aot</RuntimeIDs>
    </DefaultValidateFramework>
    <DefaultValidateFramework Include="netcore45">
      <RuntimeIDs>win8-x86;win8-x64;win8-arm</RuntimeIDs>
    </DefaultValidateFramework>
    <DefaultValidateFramework Include="netcore451">
      <RuntimeIDs>win81-x86;win81-x64;win81-arm</RuntimeIDs>
    </DefaultValidateFramework>

    <DefaultValidateFramework Include="net45" Condition="'$(ExcludeFromDesktopSupportValidation)' != 'true'">
      <RuntimeIDs>win-x86;win-x64</RuntimeIDs>
    </DefaultValidateFramework>
    <DefaultValidateFramework Include="net451" Condition="'$(ExcludeFromDesktopSupportValidation)' != 'true'">
      <RuntimeIDs>win-x86;win-x64</RuntimeIDs>
    </DefaultValidateFramework>
    <DefaultValidateFramework Include="net46" Condition="'$(ExcludeFromDesktopSupportValidation)' != 'true'">
      <!-- add additional win7 RIDs to validate up-level authoring -->
      <RuntimeIDs>win-x86;win-x64;win7-x86;win7-x64</RuntimeIDs>
    </DefaultValidateFramework>
    <DefaultValidateFramework Include="net461" Condition="'$(ExcludeFromDesktopSupportValidation)' != 'true'">
      <!-- add additional win7 RIDs to validate up-level authoring -->
      <RuntimeIDs>win-x86;win-x64;win7-x86;win7-x64</RuntimeIDs>
    </DefaultValidateFramework>
    <DefaultValidateFramework Include="net462" Condition="'$(ExcludeFromDesktopSupportValidation)' != 'true'">
      <!-- add additional win7 RIDs to validate up-level authoring -->
      <RuntimeIDs>win-x86;win-x64;win7-x86;win7-x64</RuntimeIDs>
    </DefaultValidateFramework>

    <DefaultValidateFramework Include="wpa81">
      <!-- Intentionally empty, no RIDs defined for phone-->
      <RuntimeIDs></RuntimeIDs>
    </DefaultValidateFramework>
    <DefaultValidateFramework Include="wp8">
      <!-- Intentionally empty, no RIDs defined for phone-->
      <RuntimeIDs></RuntimeIDs>
    </DefaultValidateFramework>
  </ItemGroup>

  <PropertyGroup>
    <!-- Skip validation of runtime packages, they will be validated in the context of their reference package -->
    <SkipValidatePackage Condition="'$(SkipValidateTargetFrameworks)' == '' AND '$(PackageTargetRuntime)' != ''">true</SkipValidatePackage>
    <SkipSupportCheck Condition="'$(SkipSupportCheck)' == '' AND ($(Id.StartsWith('System.Private.')) OR $(Id.StartsWith('Microsoft.NETCore.')))">true</SkipSupportCheck>
  </PropertyGroup>

  <Target Name="ValidatePackage"
          DependsOnTargets="GetPackageFiles;DetermineRuntimeDependencies"
          BeforeTargets="GenerateNuspec"
          Condition="'$(SkipValidatePackage)' != 'true'">
    <ItemGroup>
      <RuntimeDependencyProject Include="%(RuntimeDependency.OriginalItemSpec)" KeepDuplicates="false" />
      <!-- map back to the project references -->
      <RuntimeDependencyProjectFullPath Include="@(RuntimeDependencyProject->'%(FullPath)')"/>
      <ProjectReferenceFullPath Include="@(ProjectReference->'%(FullPath)')"/>
      <RuntimeProjectReference Include="@(ProjectReferenceFullPath)" Condition="'@(ProjectReferenceFullPath)' == '@(RuntimeDependencyProjectFullPath)' AND '%(Identity)' != ''"/>
    </ItemGroup>

    <ItemGroup>
      <!-- Validation framework metadata can be sepecified in multiple ways.
           By default we have a set of frameworks that we validate for.  If a package includes SupportedFramework items it will
           be tested for support of those frameworks, and not support of any thing in the default set and not the supported set.
           The default set may be completely replaced by setting IncludeDefaultValidateFramework=false and populating
           the ValidateFramework item yourself (eg: at the repo level), or by excluding individual frameworks by setting
           ExcludeDefaultValidateFramework.  Excluding a framework just means we won't explicitly validate it. -->
      <ValidateFramework Condition="'$(IncludeDefaultValidateFramework)' != 'false'" Include="@(DefaultValidateFramework)" Exclude="@(ExcludeDefaultValidateFramework)" />
    </ItemGroup>

    <ItemGroup>
      <!-- Allow for SupportedFramework to be defined as metadata on project references -->
      <SupportedFramework Include="%(File.SupportedFramework)" Condition="'%(File.SupportedFramework)' != '' AND '%(File.AssemblyVersion)' != ''">
        <Version>%(File.AssemblyVersion)</Version>
      </SupportedFramework>
    </ItemGroup>

    <ItemGroup>
      <!-- default to the current version for any unspecified SupportedFrameworks with unspecified version -->
      <SupportedFramework Condition="'%(SupportedFramework.Version)' == ''">
        <Version>$(_AssemblyVersion)</Version>
      </SupportedFramework>
    </ItemGroup>

    <!-- Get all the files from runtime implementation packages to include in reference path-->
    <MSBuild Projects="@(RuntimeProjectReference)" Targets="GetPackageFiles" Properties="$(ProjectProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="RuntimeFile" />
    </MSBuild>

    <ItemGroup>
      <EveryUnfilteredFile Include="@(RuntimeFile);@(PackageFile)" />
      
      <!-- Include all files except source files. Sources need to be deduplicated. -->
      <EveryFile Include="@(EveryUnfilteredFile)"
                 Condition="'%(EveryUnfilteredFile.IsSourceCodeFile)'!='true'" />

      <!-- Include Sources. Deduplicate so they pass package validation. -->
      <SourceFile Include="@(EveryUnfilteredFile)"
                  KeepMetadata="TargetPath;IsSourceCodeFile"
                  KeepDuplicates="false"
                  Condition="'%(EveryUnfilteredFile.IsSourceCodeFile)'=='true'" />
      <EveryFile Include="@(SourceFile)" />
    </ItemGroup>

    <ValidatePackage ContractName="$(BaseId)"
                     PackageId="$(Id)"
                     PackageVersion="$(Version)"
                     Files="@(EveryFile)"
                     SupportedFrameworks="@(SupportedFramework)"
                     Frameworks="@(ValidateFramework)"
                     RuntimeFile="$(RuntimeIdGraphDefinitionFile)"
                     FrameworkListsPath="$(FrameworkListsPath)"
                     SkipGenerationCheck="$(SkipGenerationCheck)"
                     SkipSupportCheck="$(SkipSupportCheck)"
                     SuppressionFile="$(ValidationSuppressionFile)"
                     UseNetPlatform="$(UseNetPlatform)"
                     ValidationReport="$(PackageReportPath)"
                     ContinueOnError="ErrorAndContinue"/>
  </Target>

  <Target Name="ValidateMetaPackageFramework"
          Condition="'$(MetaPackageFramework)' != ''"
          BeforeTargets="GenerateNuspec">

    <ItemGroup>
      <_ExpectedMetaDependencies Include="@(ContractAssembly)" Condition="'%(ContractAssembly.Platform)' == '$(MetaPackageFramework)'" />

      <_ExpectedMetaDependencies Remove="@(ExcludePackage);@(NoPackage)" />

      <_ActualMetaDependencies Include="@(Dependency);@(RuntimeDependency)"/>
      <!-- also consider indirect dependencies that may come from the core package -->
      <_ActualMetaDependencies Include="@(PkgProjDependency)" Condition="'%(PkgProjDependency.DependencyKind)' == 'Indirect'" />

      <_MissingMetaDependencies Include="@(_ExpectedMetaDependencies)" Exclude="@(_ActualMetaDependencies)" />
    </ItemGroup>

    <Error Text="Packages @(_MissingMetaDependencies) should be included."
           Condition="'@(_MissingMetaDependencies)' != ''"
           ContinueOnError="ErrorAndContinue" />
  </Target>

  <Target Name="CreatePackage"
          Inputs="$(NuSpecPath)"
          Outputs="$(PackageOutputPath)$(Id).$(Version).nupkg">

    <ItemGroup>
      <_missingFiles Include="@(PackageFile)" Condition="!Exists(%(FullPath))"/>
    </ItemGroup>

    <PropertyGroup>
      <_SkipCreatePackage Condition="'$(SkipCreatePackageOnMissingFiles)' == 'true' AND '@(_missingFiles)' != ''">true</_SkipCreatePackage>
    </PropertyGroup>

    <Message Condition="'$(_SkipCreatePackage)' == 'true'" Text="Skipping package creation for $(NuSpecPath) because the following files do not exist: @(_missingFiles)" />

    <NugetPack Nuspecs="$(NuSpecPath)"
               OutputDirectory="$(PackageOutputPath)"
               ExcludeEmptyDirectories="true"
               PackSymbolPackage="true"
               SymbolPackageOutputDirectory="$(SymbolPackageOutputPath)"
               Condition="'$(_SkipCreatePackage)' != 'true'"/>
    <!-- Create a marker that records the path to the generated package -->
    <WriteLinesToFile Lines="$(PackageOutputPath)$(Id).$(Version).nupkg;$(SymbolPackageOutputPath)$(Id).$(Version).symbols.nupkg"
                      File="$(NuSpecPath).pkgpath"
                      Overwrite="true"
                      Condition="'$(_SkipCreatePackage)' != 'true'"/>
  </Target>
</Project>
