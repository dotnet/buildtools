<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="12.0" DefaultTargets="Build" TreatAsLocalProperty="BuildProjectReferences" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <!-- The following properties are expected to change as we transition from
       Beta -> RC - RTM. We should set $(IncludeBuildNumberInPackageVersion)
       to false for the Beta/RC builds that get uploaded to NuGet.
  -->

  <PropertyGroup>
    <Version Condition="'$(StableVersion)' != ''">$(StableVersion)</Version>

    <PreReleaseLabel Condition="'$(PreReleaseLabel)' == ''">rc2</PreReleaseLabel>
    <IncludeBuildNumberInPackageVersion Condition="'$(IncludeBuildNumberInPackageVersion)' == ''">true</IncludeBuildNumberInPackageVersion>

    <VersionSuffix Condition="'$(PreReleaseLabel)' != ''">-$(PreReleaseLabel)</VersionSuffix>
    <VersionSuffix Condition="'$(IncludeBuildNumberInPackageVersion)' == 'true'">$(VersionSuffix)-$(BuildNumberMajor)-$(BuildNumberMinor)</VersionSuffix>

    <!--
      Empty out the project properties because we want configuration and platform to come from the individual
      projects instead of being overridden by the value the packages have.
    -->
    <ProjectProperties></ProjectProperties>

    <PackageRevStableToPrerelease Condition="'$(PackageRevStableToPrerelease)' == ''">false</PackageRevStableToPrerelease>
    <DependencyRevStableToPrerelease Condition="'$(PackageRevStableToPrerelease)' == ''">false</DependencyRevStableToPrerelease>

    <!-- By default we'll build libraries referenced by packages -->
    <BuildPackageLibraryReferences Condition="'$(BuildPackageLibraryReferences)' == ''">true</BuildPackageLibraryReferences>

    <BuildInParallel Condition="'$(BuildInParallel)' == '' AND '$(MSBuildNodeCount)' > '1'">true</BuildInParallel>
  </PropertyGroup>

  <PropertyGroup Condition="'$(IsRuntimePackage)' == 'true' or '$(PackageTargetRuntime)' != ''">
    <IdPrefix>runtime.</IdPrefix>
    <IdPrefix Condition="'$(PackageTargetRuntime)' != ''">$(IdPrefix)$(PackageTargetRuntime).</IdPrefix>
    <IdPrefix Condition="'$(PackageTargetFramework)' != ''">$(IdPrefix)$(PackageTargetFramework).</IdPrefix>
  </PropertyGroup>

  <!--
       NuSpec configuration.

       NOTE: It's by design that these properties override the project. We don't
       want projects to specify any metadata, most of the metadata should be
       the same for all packages, and the rest will be centralized.
  -->
  <PropertyGroup>
    <BaseId>$(MSBuildProjectName)</BaseId>
    <Id>$(IdPrefix)$(BaseId)</Id>
    <!-- It is by design that the Title matches the Id. We want users to get an assembly view. -->
    <Title>$(Id)</Title>
    <Authors>Microsoft</Authors>
    <Owners>microsoft,dotnetframework</Owners>
    <Description>TODO</Description>
    <LicenseUrl>http://go.microsoft.com/fwlink/?LinkId=329770</LicenseUrl>
    <IconUrl>http://go.microsoft.com/fwlink/?LinkID=288859</IconUrl>
    <Copyright>&#169; Microsoft Corporation.  All rights reserved.</Copyright>
    <Tags></Tags>
    <RequireLicenseAcceptance>true</RequireLicenseAcceptance>
    <Serviceable Condition="'$(Serviceable)' == ''">true</Serviceable>
    <!-- we depend on nuget v2.12 / v3.4 behavior NuGet doesn't support two different min client versions
         so we declare 2.12 and mention in package description that when using 3.x we require 3.4 or later -->
    <MinClientVersion3 Condition="'$(MinClientVersion3)' == '' and '$(MinClientVersion)' == ''">3.4</MinClientVersion3>
    <MinClientVersion Condition="'$(MinClientVersion)' == ''">2.12</MinClientVersion>
  </PropertyGroup>

  <!-- Shared properties -->
  <PropertyGroup>
    <PackageOutputPath Condition="'$(PackageOutputPath)' == ''">$(BaseOutputPath)pkg/</PackageOutputPath>
    <SymbolPackageOutputPath Condition="'$(SymbolPackageOutputPath)' == ''">$(BaseOutputPath)symbolpkg/</SymbolPackageOutputPath>
    <OutputPath>$(PackageOutputPath)</OutputPath>
    <NuSpecOutputPath Condition="'$(NuSpecOutputPath)' == ''">$(PackageOutputPath)specs/</NuSpecOutputPath>
    <NuSpecPath>$(NuSpecOutputPath)$(Id)$(NuspecSuffix).nuspec</NuSpecPath>
    <PackageReportDir Condition="'$(PackageReportDir)' == ''">$(PackageOutputPath)reports/</PackageReportDir>
    <PackageReportPath>$(PackageReportDir)$(Id)$(NuspecSuffix).json</PackageReportPath>
    <TargetPath>$(NuSpecPath)</TargetPath>
    <RuntimeFilePath Condition="'$(RuntimeFilePath)' == ''">$(NuSpecOutputPath)$(Id)$(NuspecSuffix)/runtime.json</RuntimeFilePath>
    <PlaceholderFile>$(MSBuildThisFileDirectory)_._</PlaceholderFile>
    <PackageDescriptionFile Condition="'$(PackageDescriptionFile)' == ''">path to descriptions.json must be specified</PackageDescriptionFile>
    <RuntimeIdGraphDefinitionFile Condition="'$(RuntimeIdGraphDefinitionFile)' == '' AND Exists('$(ProjectDir)pkg/Microsoft.NETCore.Platforms/runtime.json')">$(ProjectDir)pkg/Microsoft.NETCore.Platforms/runtime.json</RuntimeIdGraphDefinitionFile>
    <RuntimeIdGraphDefinitionFile Condition="'$(RuntimeIdGraphDefinitionFile)' == ''">$(MSBuildThisFileDirectory)runtime.json</RuntimeIdGraphDefinitionFile>
    <FrameworkListsPath Condition="'$(FrameworkListsPath)' == ''">$(MSBuildThisFileDirectory)FrameworkLists</FrameworkListsPath>
    <ValidationSuppressionFile Condition="'$(ValidationSuppressionFile)' == ''">ValidationSuppression.txt</ValidationSuppressionFile>
    <SyncInfoFile Condition="'$(SyncInfoFile)' == ''">unspecified</SyncInfoFile>
    <PackagingTaskDir Condition="'$(PackagingTaskDir)' == ''">$(MSBuildThisFileDirectory)</PackagingTaskDir>
    <LineupPackageId Condition="'$(LineupPackageId)' == ''">Microsoft.NETCore.Targets</LineupPackageId>
    <LineupPackageVersion Condition="'$(LineupPackageVersion)' == ''">1.0.1</LineupPackageVersion>
    <PlatformPackageId Condition="'$(PlatformPackageId)' == ''">Microsoft.NETCore.Platforms</PlatformPackageId>
    <PlatformPackageVersion Condition="'$(PlatformPackageVersion)' == ''">1.0.1</PlatformPackageVersion>
  </PropertyGroup>

  <!-- If this package explicitly sets the StableVersion then add it to the stable list -->
  <ItemGroup Condition="'$(StableVersion)' != ''">
    <StablePackage Include="$(Id)">
      <Version>$(StableVersion)</Version>
    </StablePackage>
  </ItemGroup>

  <UsingTask TaskName="ApplyPreReleaseSuffix" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>
  <UsingTask TaskName="GetAssemblyReferences" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>
  <UsingTask TaskName="SplitReferences" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>
  <UsingTask TaskName="GenerateRuntimeDependencies" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>
  <UsingTask TaskName="GetPackageDescription" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>
  <UsingTask TaskName="GetInboxFrameworks" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>
  <UsingTask TaskName="GetPackageVersion" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>
  <UsingTask TaskName="EnsureOOBFramework" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>
  <UsingTask TaskName="ValidatePackage" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>
  <UsingTask TaskName="CreateTrimDependencyGroups" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>
  <UsingTask TaskName="GenerateNuSpec" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>
  <UsingTask TaskName="NuGetPack" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>
  <UsingTask TaskName="ApplyBaseLine" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>
  <UsingTask TaskName="PromoteReferenceDependencies" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>
  <UsingTask TaskName="GetMinimumNETStandard" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>
  <UsingTask TaskName="SplitDependenciesBySupport" AssemblyFile="$(PackagingTaskDir)Microsoft.DotNet.Build.Tasks.Packaging.dll"/>

  <!-- Determine if we actually need to build for this architecture -->
  <!-- Packages can specifically control their architecture by specifying the PackagePlatforms
       property as a semi-colon delimited list.
       If this is not done then the package will build if the target runtime contains the current
       architecture or if we're building for x86. -->
  <PropertyGroup>
    <PackagePlatform Condition="'$(PackagePlatform)' == ''">$(Platform)</PackagePlatform>
    <PackagePlatform Condition="'$(PackagePlatform)' == 'amd64'">x64</PackagePlatform>

    <!-- build if the package specifically requests current architecture via PackagePlatforms -->
    <ShouldGenerateNuSpec Condition="$(PackagePlatforms.Contains('$(PackagePlatform);'))">true</ShouldGenerateNuSpec>
    <!-- build if PackagePlatforms is not specified and the PackageTargetRuntime contains the current architecture -->
    <ShouldGenerateNuSpec Condition="'$(PackagePlatforms)' == '' AND $(PackageTargetRuntime.Contains('-$(PackagePlatform)'))">true</ShouldGenerateNuSpec>
    <!-- build if PackagePlatforms is not specified and arch is x86 or AnyCPU -->
    <ShouldGenerateNuSpec Condition="'$(PackagePlatforms)' == '' AND ('$(PackagePlatform)' == 'x86' OR '$(PackagePlatform)' == 'AnyCPU')">true</ShouldGenerateNuSpec>
    <!-- if we built a nuspec, also pack unless explicitly set -->
    <ShouldCreatePackage Condition="'$(ShouldCreatePackage)' == ''">$(ShouldGenerateNuSpec)</ShouldCreatePackage>
    <BuildDependsOn Condition="'$(ShouldGenerateNuSpec)' == 'true'">GenerateNuSpec</BuildDependsOn>
    <BuildDependsOn Condition="'$(ShouldCreatePackage)' == 'true'">$(BuildDependsOn);CreatePackage</BuildDependsOn>
  </PropertyGroup>

  <!-- Redefine build to just create the NuSpec only, we'll create the package during ArcProjects phase -->
  <Target Name="Build"
          DependsOnTargets="$(BuildDependsOn)">

    <Message Condition="'$(ShouldGenerateNuSpec)' == 'true'"
             Text="$(MSBuildProjectName) -> $(NuSpecPath)"
             Importance="high" />

    <Message Condition="'$(ShouldGenerateNuSpec)' != 'true'"
             Text="Skipping nuspec generation for this platform."
             Importance="high" />
  </Target>

  <Target Name="Clean">
    <!-- package version is calculated so read the last version from the marker file. -->
    <ReadLinesFromFile File="$(NuSpecPath).pkgpath"
                       Condition="Exists('$(NuSpecPath).pkgpath')">
      <Output TaskParameter="Lines" ItemName="_ToBeDeleted"/>
    </ReadLinesFromFile>

    <ItemGroup>
      <_ToBeDeleted Include="$(NuSpecPath)" />
      <_ToBeDeleted Include="$(NuSpecPath).pkgpath" />
      <_ToBeDeleted Include="$(RuntimeFilePath)" />
    </ItemGroup>
    <Delete Files="@(_ToBeDeleted)" />
  </Target>

  <Target Name="Rebuild"
          DependsOnTargets="Clean;Build" />

  <!-- BEGIN project refs-->
  <!-- Don't actually walk the closure all the time, conditioned on GetClosure metadata on ProjectReference.
       Walking the closure is very expensive for many of our packages and is unecessary since we are very
       strict about assets that are included in the package.  -->
  <Target Name="_GetProjectClosure" 
          DependsOnTargets="ConvertCommonMetadataToAdditionalProperties"
          Returns="@(_ProjectReferenceClosure)">

    <!-- Get closure of indirect references if they opt-in -->
    <MSBuild Projects="@(ProjectReference)"
             Targets="_GetProjectClosure"
             Properties="$(ProjectProperties)"
             ContinueOnError="WarnAndContinue"
             BuildInParallel="$(BuildInParallel)"
             Condition="'%(ProjectReference.GetClosure)' == 'true'">
      <Output TaskParameter="TargetOutputs"
              ItemName="_ProjectReferenceClosureWithDuplicates" />
    </MSBuild>

    <!-- Remove duplicates from closure -->
    <RemoveDuplicates Inputs="@(_ProjectReferenceClosureWithDuplicates)">
      <Output TaskParameter="Filtered"
              ItemName="_ProjectReferenceClosureWithoutMetadata"/>
    </RemoveDuplicates>

    <ItemGroup>
      <!-- Remove references that are also direct references -->
      <_ProjectReferenceClosureWithoutMetadata Remove="%(ProjectReference.FullPath)" />
      <!-- We can now mark all the closure references as indirect -->
      <_ProjectReferenceClosure Include="@(_ProjectReferenceClosureWithoutMetadata)">
        <DependencyKind>Indirect</DependencyKind>
        <PackageDirectory>%(ProjectReference.PackageDirectory)</PackageDirectory>
      </_ProjectReferenceClosure>
      <!-- Now add the direct references, preserving metadata -->
      <_ProjectReferenceClosure Include="@(ProjectReference->'%(FullPath)')">
        <DependencyKind>Direct</DependencyKind>
      </_ProjectReferenceClosure>
    </ItemGroup>

  </Target>

  <Target Name="SplitProjectReferences"
          DependsOnTargets="_GetProjectClosure">
    <ItemGroup>
      <!-- Split direct and indirect project dependencies -->
      <_PkgProjProjectReferenceClosure Include="@(_ProjectReferenceClosure)"
                                      Condition="'%(_ProjectReferenceClosure.Extension)' == '.pkgproj'" />
      <_NonPkgProjProjectReferenceClosure Include="@(_ProjectReferenceClosure)"
                                         Condition="'%(_ProjectReferenceClosure.Extension)' != '.pkgproj'" />

      <!-- Split direct project dependencies -->
      <_PkgProjProjectReference Include="@(_PkgProjProjectReferenceClosure)"
                               Condition="'%(DependencyKind)' == 'Direct'" />
      <_NonPkgProjProjectReference Include="@(_NonPkgProjProjectReferenceClosure)"
                                  Condition="'%(DependencyKind)' == 'Direct'" />

    </ItemGroup>
  </Target>

  <Target Name="GetPkgProjPackageDependencies"
          Returns="@(PkgProjDependency)"
          Inputs="%(_PkgProjProjectReferenceClosure.DependencyKind)"
          Outputs="fake"
          DependsOnTargets="SplitProjectReferences">
    <MSBuild Targets="GetPackageIdentity"
             BuildInParallel="$(BuildInParallel)"
             Projects="@(_PkgProjProjectReferenceClosure)"
             Properties="%(_PkgProjProjectReferenceClosure.SetConfiguration); %(_PkgProjProjectReferenceClosure.SetPlatform)">
      <Output TaskParameter="TargetOutputs"
              ItemName="_PkgProjDependency" />
    </MSBuild>
    <ItemGroup>
      <PkgProjDependency Include="@(_PkgProjDependency)">
        <DependencyKind>%(_PkgProjProjectReferenceClosure.DependencyKind)</DependencyKind>
      </PkgProjDependency>
    </ItemGroup>
  </Target>


  <PropertyGroup>
    <!-- exclude reference assets for runtime packages
         these assets are only packaged in the reference packages.  Even
         if they have a runtime asset we package it in the reference package
         for better compression.  -->
    <ExcludeReferenceAssets Condition="'$(ExcludeReferenceAssets)' == '' AND '$(PackageTargetRuntime)' != ''">true</ExcludeReferenceAssets>
  </PropertyGroup>

  <!-- We define a custom target: GetFilesToPackage which does a minimal build of the project
       and passes all information in a single item group.
       This helps minimize the number of project evaluations and targets that build in order
       to determine the contents of the package-->
  <Target Name="ExpandProjectReferences"
          DependsOnTargets="SplitProjectReferences">

    <!-- Only rebuild project references when specified -->
    <MSBuild Targets="Build"
             BuildInParallel="$(BuildInParallel)"
             Condition="'$(BuildPackageLibraryReferences)' == 'true'"
             Projects="@(_NonPkgProjProjectReference)"
             Properties="$(ProjectProperties)"
             ContinueOnError="WarnAndContinue"/>

    <MSBuild Targets="GetFilesToPackage"
             BuildInParallel="$(BuildInParallel)"
             Projects="@(_NonPkgProjProjectReference)"
             Properties="$(ProjectProperties)">
      <Output TaskParameter="TargetOutputs"
              ItemName="_FilesToPackage" />
    </MSBuild>

    <ItemGroup>
      <_FilesToPackage Remove="@(_FilesToPackage)" Condition="'$(ExcludeReferenceAssets)' == 'true' AND '%(_FilesToPackage.IsReferenceAsset)' == 'true'" />
      <File Include="@(_FilesToPackage)">
        <PackageId>$(Id)</PackageId>
        <PackageVersion>$(Version)</PackageVersion>
        <!-- Some packages support legacy portable profiles where dependencies are provided by targeting pack -->
        <HarvestDependencies Condition="!$([System.String]::new('%(_FilesToPackage.TargetFramework)').StartsWith('portable-'))">true</HarvestDependencies>
      </File>
    </ItemGroup>

    <Error Condition="'$(SkipPackageFileCheck)' != 'true' AND
                      '%(File.SkipPackageFileCheck)' != 'true' AND
                      '%(File.FileName)' != '_' AND
                      '%(File.FileName)%(File.Extension)' != 'runtime.json' AND
                      '%(File.Extension)' != '.cs' AND
                      '%(File.Extension)' != '.vb' AND
                      !$(ID.Contains('%(File.FileName)'))"
           Text="Package $(ID) contains file with name %(File.FileName).  If this is expected you can disable this filename checking for this item or package by setting SkipPackageFileCheck = true" />
  </Target>
  <!-- END project refs-->

  <!-- BEGIN files-->
  <!-- If the "PreventImplementationReference" property is true, then don't permit references to the
    package implementation from lib.  This is used in the platform specific packages which should
    not be directly referenced by projects for implemtation dependencies. -->
  <Target Name="PreventImplementationReference">
    <ItemGroup Condition="'$(PreventImplementationReference)' == 'true'">
      <PackageFile Include="$(PlaceholderFile)">
        <PackageId>$(Id)</PackageId>
        <PackageVersion>$(Version)</PackageVersion>
        <TargetPath Condition="'$(UseNetPlatform)' != 'true'">ref/netstandard</TargetPath>
        <TargetPath Condition="'$(UseNetPlatform)' == 'true'">ref/dotnet</TargetPath>
      </PackageFile>
    </ItemGroup>
  </Target>

  <!--
      InboxOnTargetFramework: contract implementation and reference are inbox, use placeholders for both
      NotSupportedOnTargetFramework: contract should not be supported, use place holder for lib
      ExternalOnTargetFramework: contract implementation is provided by another package, use placeholders for both
  -->
  <Target Name="AddPlaceholders"
          DependsOnTargets="ExpandProjectReferences;PreventImplementationReference"
          Inputs="%(InboxOnTargetFramework.Identity);%(NotSupportedOnTargetFramework.Identity);%(ExternalOnTargetFramework.Identity)"
          Outputs="fake">
    <ItemGroup>
      <_targetItem Include="@(InboxOnTargetFramework)"/>
      <_targetItem Include="@(NotSupportedOnTargetFramework)"/>
      <_targetItem Include="@(ExternalOnTargetFramework)"/>
    </ItemGroup>
    <PropertyGroup>
      <_target>%(_targetItem.Identity)</_target>
      <_targetRuntime>$(PackageTargetRuntime)</_targetRuntime>
      <_targetRuntime Condition="'%(_targetItem.PackageTargetRuntime)' != ''">%(_targetItem.PackageTargetRuntime)</_targetRuntime>
      <!-- don't use 'any' in paths due to https://github.com/NuGet/Home/issues/1676 -->
      <_targetRuntime Condition="'$(_targetRuntime)' == 'any'"></_targetRuntime>
      <!-- include a ref placeholder for everything but NotSupportedOnTargetFramework, never put placeholders in runtime packages -->
      <_targetRef Condition="'%(NotSupportedOnTargetFramework.Identity)' == '' AND '$(PackageTargetRuntime)' == ''">true</_targetRef>
    </PropertyGroup>
    <ItemGroup>
      <File Include="$(PlaceholderFile)">
        <PackageId>$(Id)</PackageId>
        <PackageVersion>$(Version)</PackageVersion>
        <TargetPath Condition="'$(_targetRuntime)' != ''">runtimes/$(_targetRuntime)/lib/$(_target)</TargetPath>
        <TargetPath Condition="'$(_targetRuntime)' == ''">lib/$(_target)</TargetPath>
      </File>
      <File Include="$(PlaceholderFile)" Condition="'$(_targetRef)' == 'true'">
        <PackageId>$(Id)</PackageId>
        <PackageVersion>$(Version)</PackageVersion>
        <TargetPath>ref/$(_target)</TargetPath>
      </File>
      <FrameworkReference Condition="'%(InboxOnTargetFramework.AsFrameworkReference)' == 'true'" Include="$(Id)">
        <TargetFramework>$(_target)</TargetFramework>
      </FrameworkReference>
      <FrameworkReference Condition="'%(InboxOnTargetFramework.FrameworkReference)' != ''" Include="%(InboxOnTargetFramework.FrameworkReference)">
        <TargetFramework>$(_target)</TargetFramework>
      </FrameworkReference>
      <Dependency Include="_._">
        <TargetFramework>$(_target)</TargetFramework>
      </Dependency>
    </ItemGroup>
  </Target>

  <Target Name="ConvertItems"
          DependsOnTargets="ExpandProjectReferences;AddPlaceholders">
    <CreateItem Include="@(ProjectReferenceOutput)">
      <Output TaskParameter="Include"
              ItemName="File"/>
    </CreateItem>
    <ItemGroup>
      <_LinkedContentFiles Include="@(Content)"
                           Condition="'%(Content.Link)' != ''" />
      <_UnlinkedContentFiles Include="@(Content)"
                             Condition="'%(Content.Link)' == ''" />
    </ItemGroup>
    <CreateItem Include="@(_LinkedContentFiles)"
                AdditionalMetadata="TargetPath=%(Link)">
      <Output TaskParameter="Include"
              ItemName="File"/>
    </CreateItem>
    <CreateItem Include="@(_UnlinkedContentFiles)"
                AdditionalMetadata="TargetPath=%(RelativeDir)">
      <Output TaskParameter="Include"
              ItemName="File"/>
    </CreateItem>

    <!-- We need to special case library files in later phases. In order to make this
         easier, we add custom metadata 'IsLibrary' that indicates whether the file is
         targeting the lib folder or not. -->

    <ItemGroup>
      <_FileWithIsLibrary Include="@(File)"
                          Condition="'%(File.TargetPath)' == 'lib' OR
                                     $([System.String]::Copy('%(File.TargetPath)').ToLower().StartsWith('lib\')) OR
                                     $([System.String]::Copy('%(File.TargetPath)').ToLower().StartsWith('lib/'))">
        <PackageDirectory>Lib</PackageDirectory>
      </_FileWithIsLibrary>
      <_FileWithIsLibrary Include="@(File)"
                          Condition="'%(File.TargetPath)' != 'lib' AND
                                     !$([System.String]::Copy('%(File.TargetPath)').ToLower().StartsWith('lib\')) AND
                                     !$([System.String]::Copy('%(File.TargetPath)').ToLower().StartsWith('lib/'))">
        <PackageDirectory></PackageDirectory>
      </_FileWithIsLibrary>
      <File Remove="@(File)" />
      <File Include="@(_FileWithIsLibrary)" />
    </ItemGroup>
  </Target>

  <!-- Ensures that OOB frameworks aren't obscured by placeholders for inbox frameworks
       This is needed because nuget treats portable implementations as having less
       precedence than platform specific implementations of any version and we
       put a place-holder in the platform specific folder when an asset is inbox. -->
  <ItemGroup>
    <OutOfBoxFramework Include="netcore50">
      <RuntimeId>win10</RuntimeId>
    </OutOfBoxFramework>
  </ItemGroup>
  <Target Name="EnsureOOBFramework"
          DependsOnTargets="AddPlaceholders;ConvertItems">
    <EnsureOOBFramework Condition="'@(OutOfBoxFramework)' != ''" OOBFrameworks="@(OutOfBoxFramework)" Files="@(File)" RuntimeJson="$(RuntimeIdGraphDefinitionFile)" RuntimeId="$(PackageTargetRuntime)">
      <Output TaskParameter="AdditionalFiles" ItemName="File" />
    </EnsureOOBFramework>
  </Target>

  <Target Name="GetFiles"
          Returns="@(File)"
          DependsOnTargets="ConvertItems;EnsureOOBFramework" />

  <!-- Don't do any filtering of files.
       We explicitly determine package content so we do not need to
       filter out files that come from dependent packages. -->
  <Target Name="GetPackageFiles"
          Returns="@(PackageFile)"
          DependsOnTargets="GetFiles">
    <ItemGroup>
      <!-- Include all files except source files. Sources need to be deduplicated. -->
      <PackageFile Include="@(File)" Condition="'%(File.IsSourceCodeFile)'!='true'" />
      <PackageFile Condition="'%(PackageFile.PackageId)' == ''">
        <PackageId>$(Id)</PackageId>
        <PackageVersion>$(Version)</PackageVersion>
      </PackageFile>

      <!-- Include Sources. Deduplicate so the nuspec doesn't contain multiple entries for each source file. -->
      <PackageSources Include="@(File)"
                      KeepMetadata="TargetPath;IsSourceCodeFile"
                      KeepDuplicates="false"
                      Condition="'%(File.IsSourceCodeFile)'=='true'" />
      <!-- Add a placeholder source file if there are symbols but no sources. -->
      <PackageSymbolFiles Include="@(File)" Condition="'%(File.IsSymbolFile)'=='true'" />
      <PackageSources Include="$(PlaceholderFile)" Condition="'@(PackageSymbolFiles)'!='' AND '@(PackageSources)'==''">
        <IsSourceCodeFile>true</IsSourceCodeFile>
        <TargetPath>src</TargetPath>
      </PackageSources>
      <PackageFile Include="@(PackageSources)" />

      <!-- Nuget will treat TargetPath as a directory if the extensions dont match,
           however we need to package files without an extension (Unix exectuables).
           As such nuget will always consider TargetPath to be a file path for these
           files.  Ensure that the TargetPath is the file path for these files. -->
      <PackageFile Condition="'%(Extension)' == ''">
        <TargetPath>%(PackageFile.TargetPath)/%(FileName)</TargetPath>
      </PackageFile>
    </ItemGroup>
  </Target>
  <!-- END files-->

  <!-- BEGIN dependencies-->
  <Target Name="AssignPkgProjPackageDependenciesTargetFramework"
          DependsOnTargets="GetPkgProjPackageDependencies;GetFiles">

    <SplitDependenciesBySupport Condition="'$(SplitDependenciesBySupport)' == 'true'"
                                OriginalDependencies="@(PkgProjDependency)">
      <Output TaskParameter="SplitDependencies" ItemName="_SplitPkgProjDependency" />
    </SplitDependenciesBySupport>

    <ItemGroup Condition="'@(_SplitPkgProjDependency)' != ''">
      <PkgProjDependency Remove="@(PkgProjDependency)" />
      <PkgProjDependency Include="@(_SplitPkgProjDependency)" />
    </ItemGroup>

    <ItemGroup>
      <!-- ensure that unconstrained dependencies are also expanded in constrained TFM groups -->
      <_PkgProjDependencyWithoutTFM Include="@(PkgProjDependency)" Condition="'%(PkgProjDependency.TargetFramework)' == '' AND '%(PkgProjDependency.TargetRuntime)' == '' AND '%(PkgProjDependency.DoNotExpand)' != 'true'" />
      <_AllPkgProjTFMs Include="%(PkgProjDependency.TargetFramework)" Condition="'%(PkgProjDependency.DependencyKind)' == 'Direct'" />
      <!-- Include file TFMs -->
      <_AllPkgProjTFMs Include="%(File.TargetFramework)" Condition="'%(File.TargetFramework)' != ''" />

      <!-- Remove dependencies without a TFM so they can be replaced -->
      <PkgProjDependency Remove="@(_PkgProjDependencyWithoutTFM)" />
      <!-- operate on pkgproj dependencies and file dependencies -->
      <PkgProjDependency Include="@(_PkgProjDependencyWithoutTFM)">
        <TargetFramework>%(_AllPkgProjTFMs.Identity)</TargetFramework>
      </PkgProjDependency>

      <Dependency Include="@(PkgProjDependency)"
                  Condition="'%(PkgProjDependency.DependencyKind)' == 'Direct'" />
    </ItemGroup>
  </Target>

  <Target Name="DetermineRuntimeDependencies"
          DependsOnTargets="AssignPkgProjPackageDependenciesTargetFramework"
          Returns="@(RuntimeDependency)">

    <!-- see if we have any runtime dependencies to write to runtime.json -->
    <ItemGroup>
      <RuntimeDependency Condition="'%(Dependency.TargetRuntime)' != ''" Include="@(Dependency)"/>
      <RuntimeDependency>
        <TargetPackage Condition="'%(RuntimeDependency.TargetPackage)' == ''">$(Id)</TargetPackage>
      </RuntimeDependency>
      <!-- don't include runtime depdendencies in the dependency list, they'll be written to the runtime.json -->
      <Dependency Remove="@(RuntimeDependency)"/>
    </ItemGroup>

    <Error Text="Packages that are constrained by runtime should not have runtime dependencies.  They will be ignored by nuget"
           Condition="'$(PackageTargetRuntime)' != '' AND '@(RuntimeDependency)' != ''" />

    <!-- determine if there is a file to be updated, and setup the output file -->
    <PropertyGroup>
      <RuntimeFileSource Condition="'%(File.FileName)%(File.Extension)' == 'runtime.json'">%(File.Identity)</RuntimeFileSource>
      <_runtimeJsonIncluded Condition="'$(IsLineupPackage)' == 'true' OR '$(IncludeRuntimeJson)' == 'true'">true</_runtimeJsonIncluded>
    </PropertyGroup>

    <!-- only include runtime.json in lineup packages -->
    <ItemGroup Condition="'$(_runtimeJsonIncluded)' == 'true'">
      <!-- if we are updating, remove it from the file group, we'll replace it with the generated version -->
      <PackageFile Condition="'$(RuntimeFileSource)' != ''" Remove="$(RuntimeFileSource)"/>
      <PackageFile Include="$(RuntimeFilePath)">
        <PackageId>$(Id)</PackageId>
        <PackageVersion>$(Version)</PackageVersion>
        <IsLibrary>false</IsLibrary>
      </PackageFile>
    </ItemGroup>
  </Target>

  <!-- Harvest dependencies from assembly references.
       Assume version of package dependency == assembly version of dependency (3-part).
       For prerelease (not stable) packages apply a pre-release suffix to the dependency -->
  <Target Name="GetFilePackageReferences"
          DependsOnTargets="GetFiles"
          Condition="'$(OmitDependencies)' != 'true'"
          Inputs="%(File.Identity);%(File.TargetFramework)"
          Outputs="fake">
    <!-- Generate package references based on assembly dependencies -->
    <GetAssemblyReferences Assemblies="@(File)" Condition="'%(File.HarvestDependencies)' == 'true' and '%(File.Extension)' == '.dll'">
      <Output TaskParameter="ReferencedAssemblies"
              ItemName="_FileReferencedAssemblies"/>
      <Output TaskParameter="ReferencedNativeLibraries"
              ItemName="_FileReferencedNativeLibraries"/>
    </GetAssemblyReferences>

    <PropertyGroup>
      <_TargetFramework>%(File.TargetFramework)</_TargetFramework>
    </PropertyGroup>

    <SplitReferences References="@(_FileReferencedAssemblies)"
                     TargetFramework="$(_TargetFramework)"
                     FrameworkListsPath="$(FrameworkListsPath)">
      <Output TaskParameter="FrameworkReferences" ItemName="_FileFrameworkReference"/>
      <Output TaskParameter="PackageReferences" ItemName="_FilePackageReference"/>
    </SplitReferences>

    <ItemGroup Condition="'@(_FilePackageReference)' != ''">
      <_FilePackageReference Remove="corefx;mscorlib;System;System.Core;System.Xml;Windows" />

      <_FilePackageReferencePrivate Include="@(_FilePackageReference)"
                                    Condition="$([System.String]::new('%(Identity)').StartsWith('System.Private.'))"/>

      <!-- exclude any System.Private dependencies that aren't known packages, where known packages are in BaseLinePackage -->
      <PackageDependencyExclude Include="@(_FilePackageReferencePrivate)" Exclude="@(BaseLinePackage)" />
      <_FilePackageReference Remove="@(PackageDependencyExclude)"/>

      <!-- Projects may specify additional references by assembly name & identity that we'll process
           applying pre-release logic -->
      <_FilePackageReference Include="@(AdditionalAssemblyReference)"/>

      <_FilePackageReference Condition="'%(Identity)' == '@(FileRuntimeDependency)'">
        <TargetRuntime>@(FileRuntimeDependency->'%(TargetRuntime)')</TargetRuntime>
      </_FilePackageReference>
    </ItemGroup>

    <ItemGroup Condition="'@(_FileReferencedNativeLibraries)' != ''">
      <!-- intersect with NativeLibrary and add Package metadata from NativeLibrary, preserving native lib file name in metadata -->
      <_FileReferencedNativeLibrariesWithPackage Include="@(_FileReferencedNativeLibraries)"
                                                 Condition="'@(_FileReferencedNativeLibraries)' == '@(NativeLibrary)' AND '%(Identity)' != ''">
        <Package>@(NativeLibrary->'%(Package)')</Package>
        <NativeLibrary>%(Identity)</NativeLibrary>
      </_FileReferencedNativeLibrariesWithPackage>

      <_FilePackageReference Include="@(_FileReferencedNativeLibrariesWithPackage->'%(Package)')" />
    </ItemGroup>

    <ItemGroup>
      <FilePackageDependency Include="@(_FilePackageReference)" />
      <!-- Only add framework references for desktop frameworks -->
      <FrameworkReference Condition="$(_TargetFramework.StartsWith('net4'))" Include="@(_FileFrameworkReference)" KeepDuplicates="false" />
    </ItemGroup>
  </Target>

  <Target Name="GetNuGetPackageDependencies"
          DependsOnTargets="CreateVersionFileDuringBuild;GetFilePackageReferences;DetermineRuntimeDependencies">
    <PropertyGroup>
      <!-- determine if we have any reference assets in the package (files in the ref folder) -->
      <_containsReferenceAsset Condition="'%(File.IsReferenceAsset)' == 'true'">true</_containsReferenceAsset>
    </PropertyGroup>

    <ItemGroup Condition="'$(_containsReferenceAsset)' == 'true'">
      <!-- If the package contains a reference asset, then make all non-reference dependencies
           exclude compile assets, so as not to leak implementation dependencies into the compile
           graph.-->
      <FilePackageDependency>
        <Exclude Condition="'%(FilePackageDependency.IsReferenceAsset)' != 'true'">Compile</Exclude>
      </FilePackageDependency>
    </ItemGroup>

    <!-- Add a dependency on the lineup & platform package if this package has runtime dependencies and no runtime.json -->
    <ItemGroup Condition="'@(RuntimeDependency)' != '' AND '$(_runtimeJsonIncluded)' != 'true' AND '$(ExcludeLineupReference)' != 'true'">
      <!-- Add to any TargetFramework that isn't a placeholder-->
      <_runtimeDependenciesTargetFramework Include="%(File.TargetFramework)" 
                                           Condition="'%(File.Identity)' != '$(PlaceholderFile)'" 
                                           KeepDuplicates="false" />
      <!-- remove any frameworks that have an impl in this package -->
      <_runtimeDependenciesTargetFramework Remove="%(File.TargetFramework)" 
                                           Condition="$([System.String]::new('%(File.TargetPath)').StartsWith('lib/', StringComparison.OrdinalIgnoreCase))" />
      <FilePackageDependency Include="$(LineupPackageId)">
        <Version>$(LineupPackageVersion)</Version>
        <TargetFramework>%(_runtimeDependenciesTargetFramework.Identity)</TargetFramework>
      </FilePackageDependency>
      <FilePackageDependency Include="$(PlatformPackageId)">
        <Version>$(PlatformPackageVersion)</Version>
        <TargetFramework>%(_runtimeDependenciesTargetFramework.Identity)</TargetFramework>
      </FilePackageDependency>
    </ItemGroup>

    <!-- Add a dependency on the runtime graph package for every TFM that has RID-specific assets and is not already a runtime package -->
    <ItemGroup Condition="'$(PackageTargetRuntime)' == '' AND '$(ExcludeRuntimeReference)' != 'true'">
      <_ridSpecificTargetFrameworks Include="@(File->'%(TargetFramework)')"
                                    Condition="$([System.String]::new('%(File.TargetPath)').StartsWith('runtimes/', StringComparison.OrdinalIgnoreCase))
                                               AND '%(File.Identity)' != '$(PlaceholderFile)'" />
      <!-- remove any frameworks that have a RID-less impl in this package-->
      <_ridSpecificTargetFrameworks Remove="%(File.TargetFramework)" 
                                           Condition="$([System.String]::new('%(File.TargetPath)').StartsWith('lib/', StringComparison.OrdinalIgnoreCase))" />
        
      <FilePackageDependency Include="$(PlatformPackageId)" Condition="'@(_ridSpecificTargetFrameworks)' != ''">
        <Version>$(PlatformPackageVersion)</Version>
        <TargetFramework>%(_ridSpecificTargetFrameworks.Identity)</TargetFramework>
      </FilePackageDependency>
    </ItemGroup>

    <!-- We can reduce the number of dependencies listed for any framework that has
         inbox implementations since that framework doesn't need the packages for
         compile/runtime.  This reduces the noise when consuming our packages in
         packages.config based projects.  -->
    <CreateTrimDependencyGroups Dependencies="@(FilePackageDependency);@(Dependency)"
                      FrameworkListsPath="$(FrameworkListsPath)"
                      Files="@(File)"
                      UseNetPlatform="$(UseNetPlatform)"
                      Condition="'@(FilePackageDependency)' != '' AND '$(PackageTargetRuntime)' == ''">
      <Output TaskParameter="TrimmedDependencies" ItemName="FilePackageDependency" />
    </CreateTrimDependencyGroups>

    <!-- Promote reference dependencies to implementation TargetFrameworks -->
    <PromoteReferenceDependencies Dependencies="@(FilePackageDependency)"
                                  FrameworkListsPath="$(FrameworkListsPath)"
                                  Condition="'@(FilePackageDependency)' != ''">
      <Output TaskParameter="PromotedDependencies" ItemName="FilePackageDependency" />
    </PromoteReferenceDependencies>

    <Error Condition="'@(BaseLinePackage)' == '' AND '@(FilePackageDependency)' != '' AND '$(BaseLinePackageDependencies)' != 'false'" 
           Text="The BaseLinePackage item is not defined: ensure you have imported Microsoft.Private.PackageBaseLine.props from the Microsoft.Private.PackageBaseLine package" />
    <ApplyBaseLine OriginalDependencies="@(FilePackageDependency)" BaseLinePackages="@(BaseLinePackage)" Condition="'$(BaseLinePackageDependencies)' != 'false'">
      <Output TaskParameter="BaseLinedDependencies" ItemName="_BaseLinedDependencies" />
    </ApplyBaseLine>

    <!-- if not baselining, flow the dependencies unmodified -->
    <ItemGroup Condition="'$(BaseLinePackageDependencies)' == 'false'">
      <_BaseLinedDependencies Include="@(FilePackageDependency)" />
    </ItemGroup>

    <Error Condition="'@(_BaseLinedDependencies)' != '' AND '@(StablePackage)' == ''" Text="The StablePackage item is not defined: ensure you have imported Microsoft.Private.PackageBaseLine.props from the Microsoft.Private.PackageBaseLine package" />
    <ApplyPreReleaseSuffix Condition="'@(_BaseLinedDependencies)' != ''" StablePackages="@(StablePackage)" OriginalPackages="@(_BaseLinedDependencies)" PreReleaseSuffix="$(VersionSuffix)" RevStableToPrerelease="$(DependencyRevStableToPrerelease)">
      <Output TaskParameter="UpdatedPackages" ItemName="Dependency"/>
    </ApplyPreReleaseSuffix>
  </Target>

  <Target Name="GetPackageDependencies"
          DependsOnTargets="AssignPkgProjPackageDependenciesTargetFramework;GetNuGetPackageDependencies"
          Returns="@(Dependency)">
  </Target>
  <!-- END dependencies-->

  <!-- Generates a runtime.json file containing all dependencies with TargetRuntime -->
  <Target Name="GenerateRuntimeDependencies"
          DependsOnTargets="DetermineRuntimeDependencies">
    <ItemGroup>
      <LineupProjectReference Include="@(ProjectReference)" />
    </ItemGroup>

    <!-- Lineups need to have all runtime dependencies to ensure that they are part of the compile graph -->
    <MSBuild Projects="@(LineupProjectReference)" 
             Targets="DetermineRuntimeDependencies" 
             Condition="'$(IsLineupPackage)' == 'true'"
             BuildInParallel="$(BuildInParallel)"
             Properties="$(ProjectProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="_indirectRuntimeDependencies" />
    </MSBuild>

    <!-- pass both RuntimeDependencies and regular dependencies.
         Only RuntimeDependencies will be generated, but Dependencies are required
         since they may be the target of a RuntimeDependency -->
    <GenerateRuntimeDependencies Condition="'@(RuntimeDependency)' != '' OR '@(_indirectRuntimeDependencies)' != ''"
                                 Dependencies="@(RuntimeDependency);@(Dependency);@(_indirectRuntimeDependencies)"
                                 PackageId="$(Id)"
                                 RuntimeJsonTemplate="$(RuntimeFileSource)"
                                 RuntimeJson="$(RuntimeFilePath)"
                                 EnsureBase="$(IsLineupPackage)"/>
  </Target>

  <Target Name="EnsureEmptyPackage"
          DependsOnTargets="DetermineRuntimeDependencies;GetPackageFiles">
    <!-- Nuget will include all files when nuspec is empty, ensure we have at least one file to avoid that -->
    <ItemGroup Condition="'@(PackageFile)' == ''">
      <PackageFile Include="$(PlaceholderFile)">
        <PackageId>$(Id)</PackageId>
        <PackageVersion>$(Version)</PackageVersion>
        <IsLibrary>false</IsLibrary>
      </PackageFile>
    </ItemGroup>
  </Target>


  <!-- BEGIN Metadata-->

  <!-- Walks every project gathering its AssemblyVersion, choosing the highest -->
  <!-- Skipped if the package explicitly defines a version -->
  <Target Name="GetAssemblyVersionFromProjects"
          Condition="$(Version) == ''"
          DependsOnTargets="GetFiles">

    <GetPackageVersion Files="@(File)">
      <Output TaskParameter="Version" PropertyName="_AssemblyVersion" />
    </GetPackageVersion>

    <Error Condition="'$(_AssemblyVersion)' == ''"
           Text="No assembly version could be determined." />
  </Target>

  <!-- Calculates the package version including any prerelease suffix -->
  <Target Name="CalculatePackageVersion"
        DependsOnTargets="CreateVersionFileDuringBuild;GetAssemblyVersionFromProjects">

    <Error Text="No version could be detected.  Either specify the Version property or provide at least one managed assembly."
           Condition="'$(Version)' == '' AND '$(_AssemblyVersion)' == ''" />

    <ItemGroup>
      <_thisPackage Include="$(Id)">
        <Version Condition="'$(Version)' != ''">$(Version)</Version>
        <Version Condition="'$(Version)' == ''">$(_AssemblyVersion)</Version>
      </_thisPackage>
    </ItemGroup>

    <ApplyPreReleaseSuffix StablePackages="@(StablePackage)" OriginalPackages="@(_thisPackage)" PreReleaseSuffix="$(VersionSuffix)" RevStableToPrerelease="$(PackageRevStableToPrerelease)">
      <Output TaskParameter="UpdatedPackages" ItemName="_thisPackageFinal"/>
    </ApplyPreReleaseSuffix>

    <PropertyGroup>
      <Version>%(_thisPackageFinal.Version)</Version>
    </PropertyGroup>
  </Target>

  <!-- Permit setting TargetFramework and add our own metadata (TargetRuntime) -->
  <Target Name="GetPackageIdentity"
          Returns="@(_PackageIdentity)"
          DependsOnTargets="GetFiles;CalculatePackageVersion">

    <ItemGroup>
      <_referenceFrameworks Include="%(File.TargetFramework)" Condition="'%(File.IsReferenceAsset)' == 'true'" />
    </ItemGroup>

    <GetMinimumNETStandard Condition="'$(MinimumNETStandard)' == ''"
                           Frameworks="@(_referenceFrameworks)">
      <Output TaskParameter="MinimumNETStandard" PropertyName="MinimumNETStandard"/>
    </GetMinimumNETStandard>

    <ItemGroup>
      <_PackageIdentity Include="$(Id)">
        <Version>$(Version)</Version>
        <TargetFramework Condition="'$(PackageTargetFramework)' != ''">$(PackageTargetFramework)</TargetFramework>
        <TargetRuntime Condition="'$(PackageTargetRuntime)' != ''">$(PackageTargetRuntime)</TargetRuntime>
        <MinimumNETStandard Condition="'$(MinimumNETStandard)' != ''">$(MinimumNETStandard)</MinimumNETStandard>
      </_PackageIdentity>
    </ItemGroup>
  </Target>

  <Target Name="GetSyncInfo"
    Condition="Exists('$(SyncInfoFile)')">
    <ReadLinesFromFile
      File="$(SyncInfoFile)">
      <Output
        TaskParameter="Lines"
        ItemName="SyncInfoLines" />
    </ReadLinesFromFile>
  </Target>

  <Target Name="GetPackageDescription"
          DependsOnTargets="GetSyncInfo">
    <PropertyGroup>
      <UseRuntimePackageDescription Condition="'$(UseRuntimePackageDescription)' == '' AND $(BaseId.StartsWith('runtime.native'))">true</UseRuntimePackageDescription>
    </PropertyGroup>

    <GetPackageDescription DescriptionFile="$(PackageDescriptionFile)"
                           Condition="'$(UseRuntimePackageDescription)' != 'true'"
                           PackageId="$(BaseId)">
      <Output TaskParameter="Description"
              PropertyName="Description" />
    </GetPackageDescription>

    <GetPackageDescription DescriptionFile="$(PackageDescriptionFile)"
                           Condition="'$(PackageTargetRuntime)' != '' OR '$(UseRuntimePackageDescription)' == 'true'"
                           PackageId="RuntimePackage">
      <Output TaskParameter="Description"
              PropertyName="RuntimeDisclaimer" />
    </GetPackageDescription>

    <!-- Looks up a message similar to "When using NuGet 3.x this package requires at least version {0}." -->
    <GetPackageDescription DescriptionFile="$(PackageDescriptionFile)"
                           Condition="'$(MinClientVersion3)' != ''"
                           PackageId="NuGet3MinVersion">
      <Output TaskParameter="Description"
              PropertyName="NuGet3MinVersionMessage" />
    </GetPackageDescription>

    <PropertyGroup>
      <Description Condition="'$(UseRuntimePackageDescription)' == 'true' AND '$(RuntimeDisclaimer)' != ''">$(RuntimeDisclaimer)</Description>
      <Description Condition="'$(UseRuntimePackageDescription)' != 'true' AND '$(RuntimeDisclaimer)' != ''">$(RuntimeDisclaimer) %0A$(Description)</Description>
      <Description Condition="'@(SyncInfoLines)' != ''">$(Description) %0A%(SyncInfoLines.Identity)</Description>
      <Description Condition="'$(MinClientVersion3)' != ''">$(Description) %0A$([System.String]::Format('$(NuGet3MinVersionMessage)', '$(MinClientVersion3)'))</Description>
    </PropertyGroup>
  </Target>

  <Target Name="GetPackageMetadata"
          DependsOnTargets="GetPackageDescription;GetPackageIdentity" />
  <!-- END Metadata -->

  <!-- BEGIN validation and output -->
  <ItemGroup>
    <!-- Default validation frameworks : every framework that supports contracts -->
    <DefaultValidateFramework Include="netcoreapp1.0">
      <RuntimeIDs>win7-x86;win7-x64;osx.10.11-x64;centos.7-x64;debian.8-x64;linuxmint.17-x64;opensuse.13.2-x64;rhel.7.2-x64;ubuntu.14.04-x64;ubuntu.16.04-x64</RuntimeIDs>
    </DefaultValidateFramework>

    <DefaultValidateFramework Include="netcore50">
      <RuntimeIDs>win10-x86;win10-x86-aot;win10-x64;win10-x64-aot;win10-arm;win10-arm-aot</RuntimeIDs>
    </DefaultValidateFramework>
    <DefaultValidateFramework Include="netcore45">
      <!-- Intentionally empty, no RIDs defined for Win8 as it must work with packages.config-->
      <RuntimeIDs></RuntimeIDs>
    </DefaultValidateFramework>
    <DefaultValidateFramework Include="netcore451">
      <!-- Intentionally empty, no RIDs defined for Win81 as it must work with packages.config-->
      <RuntimeIDs></RuntimeIDs>
    </DefaultValidateFramework>

    <DefaultValidateFramework Include="net45" Condition="'$(ExcludeFromDesktopSupportValidation)' != 'true'">
      <RuntimeIDs>;win-x86;win-x64</RuntimeIDs>
    </DefaultValidateFramework>
    <DefaultValidateFramework Include="net451" Condition="'$(ExcludeFromDesktopSupportValidation)' != 'true'">
      <RuntimeIDs>;win-x86;win-x64</RuntimeIDs>
    </DefaultValidateFramework>
    <DefaultValidateFramework Include="net46" Condition="'$(ExcludeFromDesktopSupportValidation)' != 'true'">
      <!-- additional win7 RIDs to validate up-level authoring -->
      <RuntimeIDs>;win-x86;win-x64;win7-x86;win7-x64</RuntimeIDs>
    </DefaultValidateFramework>
    <DefaultValidateFramework Include="net461" Condition="'$(ExcludeFromDesktopSupportValidation)' != 'true'">
      <!-- add additional win7 RIDs to validate up-level authoring -->
      <RuntimeIDs>;win-x86;win-x64;win7-x86;win7-x64</RuntimeIDs>
    </DefaultValidateFramework>
    <DefaultValidateFramework Include="net462" Condition="'$(ExcludeFromDesktopSupportValidation)' != 'true'">
      <!-- add additional win7 RIDs to validate up-level authoring -->
      <RuntimeIDs>;win-x86;win-x64;win7-x86;win7-x64</RuntimeIDs>
    </DefaultValidateFramework>
    <DefaultValidateFramework Include="net463" Condition="'$(ExcludeFromDesktopSupportValidation)' != 'true'">
      <!-- add additional win7 RIDs to validate up-level authoring -->
      <RuntimeIDs>;win-x86;win-x64;win7-x86;win7-x64</RuntimeIDs>
    </DefaultValidateFramework>

    <DefaultValidateFramework Include="wpa81">
      <!-- Intentionally empty, no RIDs defined for phone-->
      <RuntimeIDs></RuntimeIDs>
    </DefaultValidateFramework>
    <DefaultValidateFramework Include="wp8">
      <!-- Intentionally empty, no RIDs defined for phone-->
      <RuntimeIDs></RuntimeIDs>
    </DefaultValidateFramework>
  </ItemGroup>

  <PropertyGroup>
    <!-- Skip validation of runtime packages, they will be validated in the context of their reference package -->
    <SkipValidatePackage Condition="'$(SkipValidateTargetFrameworks)' == '' AND '$(PackageTargetRuntime)' != ''">true</SkipValidatePackage>
    <SkipSupportCheck Condition="'$(SkipSupportCheck)' == '' AND ($(Id.StartsWith('System.Private.')) OR $(Id.StartsWith('Microsoft.NETCore.')))">true</SkipSupportCheck>
  </PropertyGroup>
  
  <Target Name="GetPackageAssets"
          DependsOnTargets="GetPackageFiles;DetermineRuntimeDependencies"
          Returns="@(PackageAsset)">
    <ItemGroup>
      <RuntimeDependencyProject Include="%(RuntimeDependency.OriginalItemSpec)" KeepDuplicates="false" />
      <!-- map back to the project references -->
      <RuntimeDependencyProjectFullPath Include="@(RuntimeDependencyProject->'%(FullPath)')"/>
      <ProjectReferenceFullPath Include="@(ProjectReference->'%(FullPath)')"/>
      <RuntimeProjectReference Include="@(ProjectReferenceFullPath)" Condition="'@(ProjectReferenceFullPath)' == '@(RuntimeDependencyProjectFullPath)' AND '%(Identity)' != ''"/>
    </ItemGroup>
      

    <!-- Get all the files from runtime implementation packages to include in reference path-->
    <MSBuild Projects="@(RuntimeProjectReference)" 
             Targets="GetPackageFiles" 
             BuildInParallel="$(BuildInParallel)"
             Properties="$(ProjectProperties)">
      <Output TaskParameter="TargetOutputs" ItemName="RuntimeFile" />
    </MSBuild>

    <ItemGroup>
      <PackageAsset Include="@(RuntimeFile)"
                    Condition="'%(RuntimeFile.IsSourceCodeFile)'!='true'" />
      <PackageAsset Include="@(PackageFile)"
                    Condition="'%(PackageFile.IsSourceCodeFile)'!='true'" />
    </ItemGroup>
  </Target>

  <Target Name="ValidatePackage"
          DependsOnTargets="GetPackageAssets"
          Condition="'$(SkipValidatePackage)' != 'true'">

    <ItemGroup>
      <!-- Validation framework metadata can be sepecified in multiple ways.
           By default we have a set of frameworks that we validate for.  If a package includes SupportedFramework items it will
           be tested for support of those frameworks, and not support of any thing in the default set and not the supported set.
           The default set may be completely replaced by setting IncludeDefaultValidateFramework=false and populating
           the ValidateFramework item yourself (eg: at the repo level), or by excluding individual frameworks by setting
           ExcludeDefaultValidateFramework.  Excluding a framework just means we won't explicitly validate it. -->
      <ValidateFramework Condition="'$(IncludeDefaultValidateFramework)' != 'false'" Include="@(DefaultValidateFramework)" Exclude="@(ExcludeDefaultValidateFramework)" />
    </ItemGroup>

    <ItemGroup>
      <!-- Allow for SupportedFramework to be defined as metadata on project references -->
      <SupportedFramework Include="%(File.SupportedFramework)" Condition="'%(File.SupportedFramework)' != '' AND '%(File.AssemblyVersion)' != ''">
        <Version>%(File.AssemblyVersion)</Version>
      </SupportedFramework>
    </ItemGroup>

    <ItemGroup>
      <!-- default to the current version for any unspecified SupportedFrameworks with unspecified version -->
      <SupportedFramework Condition="'%(SupportedFramework.Version)' == ''">
        <Version>$(_AssemblyVersion)</Version>
      </SupportedFramework>
    </ItemGroup>

    <ValidatePackage ContractName="$(BaseId)"
                     PackageId="$(Id)"
                     PackageVersion="$(Version)"
                     Files="@(PackageAsset)"
                     SupportedFrameworks="@(SupportedFramework)"
                     Frameworks="@(ValidateFramework)"
                     RuntimeFile="$(RuntimeIdGraphDefinitionFile)"
                     FrameworkListsPath="$(FrameworkListsPath)"
                     SkipGenerationCheck="$(SkipGenerationCheck)"
                     SkipSupportCheck="$(SkipSupportCheck)"
                     SuppressionFile="$(ValidationSuppressionFile)"
                     UseNetPlatform="$(UseNetPlatform)"
                     ValidationReport="$(PackageReportPath)" />

    <!-- Validate that this package version is part of the baseline -->
    <ItemGroup>
      <_thisPackageBaseLine Include="@(BaseLinePackage)" Condition="'$(Id)' == '%(Identity)'" />
    </ItemGroup>
    <PropertyGroup>
      <_VersionWithoutPreRelease>$(Version)</_VersionWithoutPreRelease>
      <_VersionWithoutPreRelease Condition="$(Version.Contains('-'))">$(Version.SubString(0, $(Version.IndexOf('-'))))</_VersionWithoutPreRelease>
      <BaseLinePropsUpdateMessage Condition="'$(BaseLinePropsFile)' != ''">  Please update '$(BaseLinePropsFile)'.</BaseLinePropsUpdateMessage>
    </PropertyGroup>

    <Error Condition="'$(SkipBaseLineCheck)' != 'true' AND '@(_thisPackageBaseLine)' != '' AND '@(_thisPackageBaseLine->WithMetadataValue('Version', '$(_VersionWithoutPreRelease)'))' == ''"
           Text="This package's version '$(_VersionWithoutPreRelease)' is not part of any BaseLine '@(_thisPackageBaseLine->'%(Version)')'.$(BaseLinePropsUpdateMessage)" />
  </Target>

  <Target Name="GetValidationReport" DependsOnTargets="ValidatePackage" Returns="$(PackageReportPath)" />

  <!-- Required by Common.Targets when evaluating projectReferences -->
  <Target Name="GetNativeManifest" />
  <Target Name="GetCopyToOutputDirectoryItems" />
  
  <!-- When building in VS, ResolveProjectReferences only calls GetTargetPath 
       and expects that to return the same set of items as Targets defined by 
       ProjectReference.Targets metadata.  -->
  <Target Name="GetTargetPath" 
          DependsOnTargets="GetPackageAssets"  
          Returns="@(PackageAsset)" />
 
  <!-- App packaging support -->
  <!-- 
    Following two targets are needed to be present in every project being built
    because the app packaging targets recursively scan all projects referenced
    from projects that generate app packages for them.
  -->
  <Target Name="CleanAppxPackage" />
  <Target Name="GetPackagingOutputs" />

  <Target Name="GenerateNuSpec"
          DependsOnTargets="GetPackageDependencies;GetPackageFiles;GetPackageMetadata;GenerateRuntimeDependencies;EnsureEmptyPackage;ValidatePackage">
    <!-- Please Note:
         In order to avoid incremental build issues this target will always run.
         However, the task will make sure that it doesn't touch the file if the
         contents it would generate are identical to a previously generated
         nuspec. -->
    <GenerateNuSpec InputFileName="$(NuSpecTemplate)"
                    OutputFileName="$(NuSpecPath)"
                    MinClientVersion="$(MinClientVersion)"
                    Id="$(Id)"
                    Version="$(Version)"
                    Title="$(Title)"
                    Authors="$(Authors)"
                    Owners="$(Owners)"
                    Description="$(Description)"
                    ReleaseNotes="$(ReleaseNotes)"
                    Summary="$(Summary)"
                    Language="$(Language)"
                    ProjectUrl="$(ProjectUrl)"
                    IconUrl="$(IconUrl)"
                    LicenseUrl="$(LicenseUrl)"
                    Copyright="$(Copyright)"
                    RequireLicenseAcceptance="$(RequireLicenseAcceptance)"
                    Tags="$(Tags)"
                    DevelopmentDependency="$(DevelopmentDependency)"
                    Dependencies="@(Dependency)"
                    References="@(Reference)"
                    FrameworkReferences="@(FrameworkReference)"
                    Files="@(PackageFile)"
                    Serviceable="$(Serviceable)"/>
  </Target>

  <Target Name="CreatePackage"
          Inputs="$(NuSpecPath)"
          Outputs="$(PackageOutputPath)$(Id).$(Version).nupkg">

    <ItemGroup>
      <_missingFiles Include="@(PackageFile)" Condition="!Exists(%(FullPath))"/>
    </ItemGroup>

    <PropertyGroup>
      <_SkipCreatePackage Condition="'$(SkipCreatePackageOnMissingFiles)' == 'true' AND '@(_missingFiles)' != ''">true</_SkipCreatePackage>
    </PropertyGroup>

    <Message Condition="'$(_SkipCreatePackage)' == 'true'" Text="Skipping package creation for $(NuSpecPath) because the following files do not exist: @(_missingFiles)" />

    <NugetPack Nuspecs="$(NuSpecPath)"
               OutputDirectory="$(PackageOutputPath)"
               ExcludeEmptyDirectories="true"
               PackSymbolPackage="true"
               SymbolPackageOutputDirectory="$(SymbolPackageOutputPath)"
               AdditionalLibPackageExcludes="@(AdditionalLibPackageExcludes)"
               AdditionalSymbolPackageExcludes="@(AdditionalSymbolPackageExcludes)"
               Condition="'$(_SkipCreatePackage)' != 'true'"/>
    <!-- Create a marker that records the path to the generated package -->
    <WriteLinesToFile Lines="$(PackageOutputPath)$(Id).$(Version).nupkg;$(SymbolPackageOutputPath)$(Id).$(Version).symbols.nupkg"
                      File="$(NuSpecPath).pkgpath"
                      Overwrite="true"
                      Condition="'$(_SkipCreatePackage)' != 'true'"/>
  </Target>
</Project>
